<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano103 BSP: SYS_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano103 BSP
   &#160;<span id="projectnumber">V3.01.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano103 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SYS_T Struct Reference<div class="ingroups"><a class="el" href="group___n_a_n_o103___definitions.html">NANO103 Definitions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano103_8h_source.html">Nano103.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a98c44c630b54e2df3bf779fca81ff37e"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a98c44c630b54e2df3bf779fca81ff37e">PDID</a></td></tr>
<tr class="separator:a98c44c630b54e2df3bf779fca81ff37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378aa7441637420df17bde686e165770"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a378aa7441637420df17bde686e165770">RSTSTS</a></td></tr>
<tr class="separator:a378aa7441637420df17bde686e165770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8683a6bf8116c92108bbb38385942e0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#af8683a6bf8116c92108bbb38385942e0">IPRST1</a></td></tr>
<tr class="separator:af8683a6bf8116c92108bbb38385942e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fba5658eb489848ce7e205bb20cf4f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a15fba5658eb489848ce7e205bb20cf4f">IPRST2</a></td></tr>
<tr class="separator:a15fba5658eb489848ce7e205bb20cf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ba209e495bff5db1de35a39411cd68"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a89ba209e495bff5db1de35a39411cd68">MISCCTL</a></td></tr>
<tr class="separator:a89ba209e495bff5db1de35a39411cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3e3ddeb8141931780427b8358dc109"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#ada3e3ddeb8141931780427b8358dc109">TEMPCTL</a></td></tr>
<tr class="separator:ada3e3ddeb8141931780427b8358dc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b163f7063651f55407b0565f0a0294"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a74b163f7063651f55407b0565f0a0294">RCCFCTL</a></td></tr>
<tr class="separator:a74b163f7063651f55407b0565f0a0294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a03e10c205b034173e15b13cf250c54"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a9a03e10c205b034173e15b13cf250c54">GPA_MFPL</a></td></tr>
<tr class="separator:a9a03e10c205b034173e15b13cf250c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b93ff188c442c3ad97b3e55b215b2b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a21b93ff188c442c3ad97b3e55b215b2b">GPA_MFPH</a></td></tr>
<tr class="separator:a21b93ff188c442c3ad97b3e55b215b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54a1e3222a0f16f98af64069587b636"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#af54a1e3222a0f16f98af64069587b636">GPB_MFPL</a></td></tr>
<tr class="separator:af54a1e3222a0f16f98af64069587b636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b4dcf365ceb2fe570865a5a6d4a0e6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a44b4dcf365ceb2fe570865a5a6d4a0e6">GPB_MFPH</a></td></tr>
<tr class="separator:a44b4dcf365ceb2fe570865a5a6d4a0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc350722fe458151421ed6a33471a7e8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#acc350722fe458151421ed6a33471a7e8">GPC_MFPL</a></td></tr>
<tr class="separator:acc350722fe458151421ed6a33471a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc41156a35c42847828d926efd65b65f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#abc41156a35c42847828d926efd65b65f">GPC_MFPH</a></td></tr>
<tr class="separator:abc41156a35c42847828d926efd65b65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955475a9fe10d5a8b98cd8a509c21f9b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a955475a9fe10d5a8b98cd8a509c21f9b">GPD_MFPL</a></td></tr>
<tr class="separator:a955475a9fe10d5a8b98cd8a509c21f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72336a6b365d90b2462a3ba2300c66"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#adb72336a6b365d90b2462a3ba2300c66">GPD_MFPH</a></td></tr>
<tr class="separator:adb72336a6b365d90b2462a3ba2300c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c990a849c14895d01f3c090c5062a2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a78c990a849c14895d01f3c090c5062a2">GPE_MFPL</a></td></tr>
<tr class="separator:a78c990a849c14895d01f3c090c5062a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03540e23beda3a30fe90e9aa839368b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#af03540e23beda3a30fe90e9aa839368b">GPF_MFPL</a></td></tr>
<tr class="separator:af03540e23beda3a30fe90e9aa839368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c4205ce6e8c27ddaca0493c99cdda5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a58c4205ce6e8c27ddaca0493c99cdda5">PORCTL</a></td></tr>
<tr class="separator:a58c4205ce6e8c27ddaca0493c99cdda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ec534d4476785f80e2a0aabdefc3ec"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#aa0ec534d4476785f80e2a0aabdefc3ec">BODCTL</a></td></tr>
<tr class="separator:aa0ec534d4476785f80e2a0aabdefc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7f9d4af3099e638570526cb6f40288"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a3e7f9d4af3099e638570526cb6f40288">IVREFCTL</a></td></tr>
<tr class="separator:a3e7f9d4af3099e638570526cb6f40288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c650811df004c108b12713f305990cf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a8c650811df004c108b12713f305990cf">LDOCTL</a></td></tr>
<tr class="separator:a8c650811df004c108b12713f305990cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5779721734662259349c703f7271a7f6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a5779721734662259349c703f7271a7f6">BATDIVCTL</a></td></tr>
<tr class="separator:a5779721734662259349c703f7271a7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720cebf4699c1cad907df1df656e717"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a3720cebf4699c1cad907df1df656e717">WKSTS</a></td></tr>
<tr class="separator:a3720cebf4699c1cad907df1df656e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cd396a53f67020d7e8c287ac28092a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#aa7cd396a53f67020d7e8c287ac28092a">IRC0TCTL</a></td></tr>
<tr class="separator:aa7cd396a53f67020d7e8c287ac28092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92fafebe5cf5b0d1f04ee4083ca0b3f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#aa92fafebe5cf5b0d1f04ee4083ca0b3f">IRC0TIEN</a></td></tr>
<tr class="separator:aa92fafebe5cf5b0d1f04ee4083ca0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7a286d6b10543711649f6e000af9b8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#abc7a286d6b10543711649f6e000af9b8">IRC0TISTS</a></td></tr>
<tr class="separator:abc7a286d6b10543711649f6e000af9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158f979f2a85d5a38ffe8f7f8bd43374"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a158f979f2a85d5a38ffe8f7f8bd43374">IRC1TCTL</a></td></tr>
<tr class="separator:a158f979f2a85d5a38ffe8f7f8bd43374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25031d660098c457d75c0fc35435c898"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a25031d660098c457d75c0fc35435c898">IRC1TIEN</a></td></tr>
<tr class="separator:a25031d660098c457d75c0fc35435c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45400d7eda37292ca9e0437de46ed2ed"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a45400d7eda37292ca9e0437de46ed2ed">IRC1TISTS</a></td></tr>
<tr class="separator:a45400d7eda37292ca9e0437de46ed2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c24b30f6065a4c23ec0231b964b90b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a35c24b30f6065a4c23ec0231b964b90b">MIRCTCTL</a></td></tr>
<tr class="separator:a35c24b30f6065a4c23ec0231b964b90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7220555456cd728a11cf1211a07a60"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a5b7220555456cd728a11cf1211a07a60">MIRCTIEN</a></td></tr>
<tr class="separator:a5b7220555456cd728a11cf1211a07a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a4c8e158647c949a51d2b8752906a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a420a4c8e158647c949a51d2b8752906a">MIRCTISTS</a></td></tr>
<tr class="separator:a420a4c8e158647c949a51d2b8752906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197e4fed077b77ad85d90e67954bfb2c"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a197e4fed077b77ad85d90e67954bfb2c">REGLCTL</a></td></tr>
<tr class="separator:a197e4fed077b77ad85d90e67954bfb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e788e5913f7ec9d0032950ce7af206"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_y_s___t.html#a73e788e5913f7ec9d0032950ce7af206">RPDBCLK</a></td></tr>
<tr class="separator:a73e788e5913f7ec9d0032950ce7af206"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SYS System Manger Controller(SYS)
Memory Mapped Structure for SYS Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l00945">945</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a5779721734662259349c703f7271a7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5779721734662259349c703f7271a7f6">&#9670;&nbsp;</a></span>BATDIVCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::BATDIVCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0074] Battery Voltage Divider Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BATDIVCTL
</font><br><p> <font size="2">
Offset: 0x74  Battery Voltage Divider Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BATDIV2EN</td><td><div style="word-wrap: break-word;"><b>Battery voltage divide 2 Enable Bit
</b><br>
This bit is used to enable/disable battery voltage divider function.
<br>
0 = Battery voltage divide 2 function Disabled (default).
<br>
1 = Battery voltage divide 2 function Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03211">3211</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aa0ec534d4476785f80e2a0aabdefc3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ec534d4476785f80e2a0aabdefc3ec">&#9670;&nbsp;</a></span>BODCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::BODCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0064] Brown-out Detector Controller Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BODCTL
</font><br><p> <font size="2">
Offset: 0x64  Brown-out Detector Controller Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BODEN</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Enable Bit (Write Protect)
</b><br>
The default value is set by flash controller user configuration register CBODEN (CONFIG0 [])
<br>
This Brown-out Detector only valid in Normal Mode.
<br>
0 = Brown-out Detector function Disabled in Normal mode.
<br>
1 = Brown-out Detector function Enabled in Normal mode.
<br>
Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
Note2: LIRC must be enabled before enable BOD.
<br>
</div></td></tr><tr><td>
[2]</td><td>BODIE</td><td><div style="word-wrap: break-word;"><b>BOD Interrupt Enable Control (Write Protect)
</b><br>
0 = Interrupt does not issue when BOD occurs in Normal Mode.
<br>
1 = Interrupt issues when BOD occurs in Normal Mode.
<br>
Note1: While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high.
<br>
Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[3]</td><td>BODREN</td><td><div style="word-wrap: break-word;"><b>Brown-out Reset Enable Bit (Write Protect)
</b><br>
The default value is set by flash controller user configuration register CBOV(CONFIG0[]) bit .
<br>
0 = Brown-out RESET function Disabled in Normal Mode.
<br>
1 = Brown-out RESET function Enabled in Normal Mode.
<br>
Note1: While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
<br>
Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[4]</td><td>BODIF</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Interrupt Flag
</b><br>
0 = Brown-out Detector does not detect any voltage drift at VDD down through or up through the target detected voltage after interrupt is enabled.
<br>
1 = When Brown-out Detector detects the VDD is dropped down through the target detected voltage or the VDD is raised up through the target detected voltage, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[6]</td><td>BODOUT</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Output Status
</b><br>
0 = Brown-out Detector output status is 0.
<br>
It means the detected voltage is higher than BODVL setting or BODEN is 0.
<br>
1 = Brown-out Detector output status is 1.
<br>
It means the detected voltage is lower than BODVL setting
<br>
If the BODEN is 0, BOD function disabled , this bit always responds 0.
<br>
Note: This bit is ready-only.
<br>
</div></td></tr><tr><td>
[7]</td><td>LVREN</td><td><div style="word-wrap: break-word;"><b>Low Voltage Reset Enable Bit (Write Protect)
</b><br>
The LVR function resets the chip when the input power voltage is lower than LVR circuit setting
<br>
LVR function is enabled by default.
<br>
0 = Low Voltage Reset function Disabled.
<br>
1 = Low Voltage Reset function Enabled.
<br>
Note1: After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
<br>
Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
Note3: LIRC must be enabled before enable LVR.
<br>
</div></td></tr><tr><td>
[8]</td><td>LPBODEN</td><td><div style="word-wrap: break-word;"><b>Low Power Brown-out Detector Enable Bit (Write Protect)
</b><br>
Low Power Brown-out Detector only valid in Power Down mode.
<br>
0 = Low Power Brown-out Detector function Disabled in Power Down mode.
<br>
1 = Low Power Brown-out Detector function Enabled in Power Down mode.
<br>
Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
Note2: LIRC must be enabled before enable BOD.
<br>
</div></td></tr><tr><td>
[9]</td><td>LPBODVL</td><td><div style="word-wrap: break-word;"><b>Low Power Brown-out Detector Threshold Voltage Selection (Write Protect)
</b><br>
Low Power Brown-out Detector only valid in Power Down mode.
<br>
0 = Low Power Brown-Out Detector threshold voltage is 2.0V in Power Down mode.
<br>
1 = Low Power Brown-Out Detector threshold voltage is 2.5V in Power Down mode.
<br>
Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[10]</td><td>LPBODIE</td><td><div style="word-wrap: break-word;"><b>Low Power BOD Interrupt Enable Control (Write Protect)
</b><br>
Low Power Brown-out Detector only valid in Power Down mode.
<br>
0 = Interrupt does not issue when LPBOD occurs in Power Down mode.
<br>
1 = Interrupt issues when LPBOD occurs in Power Down mode
<br>
Note1: While the LPBOD function is enabled (LPBODEN high) and LPBOD interrupt function is enabled (LPBODIE high), LPBOD will assert an interrupt if BODOUT is high
<br>
Note2: This bit is write protected
<br>
Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[11]</td><td>LPBODREN</td><td><div style="word-wrap: break-word;"><b>Low Power Brown-out Reset Enable Bit (Write Protect)
</b><br>
Low Power Brown-out Detector only valid in Power Down mode.
<br>
0 = Low power Brown-out Detector RESET function Disabled in Power Down mode.
<br>
1 = Low Power Brown-out Detector RESET function Enabled in Power Down mode.
<br>
Note1: While the Low power Brown-out Detector function is enabled (LPBODEN high) and LPBOD reset function is enabled (LPBODREN high), LPBOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
<br>
Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>BODVL</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Threshold Voltage Selection (Write Protect)
</b><br>
The default value is set by flash controller user configuration register CBOV (CONFIG0[]).
<br>
0000 = Brown-Out Detector threshold voltage is 1.7V.
<br>
0001 = Brown-Out Detector threshold voltage is 1.8V.
<br>
0010 = Brown-Out Detector threshold voltage is 1.9V.
<br>
0011 = Brown-Out Detector threshold voltage is 2.0V.
<br>
0100 = Brown-Out Detector threshold voltage is 2.1V.
<br>
0101 = Brown-Out Detector threshold voltage is 2.2V.
<br>
0110 = Brown-Out Detector threshold voltage is 2.3V.
<br>
0111 = Brown-Out Detector threshold voltage is 2.4V.
<br>
1000 = Brown-Out Detector threshold voltage is 2.5V.
<br>
1001 = Brown-Out Detector threshold voltage is 2.6V.
<br>
1010 = Brown-Out Detector threshold voltage is 2.7V.
<br>
1011 = Brown-Out Detector threshold voltage is 2.8V.
<br>
1100 = Brown-Out Detector threshold voltage is 2.9V.
<br>
1101 = Brown-Out Detector threshold voltage is 3.0V.
<br>
1110 = Brown-Out Detector threshold voltage is 3.1V.
<br>
1111 = Reserved.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>LPBOD20TRIM</td><td><div style="word-wrap: break-word;"><b>Low power BOD 2.0 TRIM Value (Write Protect)
</b><br>
This value is used to control BOD20 detect voltage level in power-down mode, nominal 2.0 V
<br>
Higher trim value, higher detection voltage.
<br>
Note: These bits are write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>LPBOD25TRIM</td><td><div style="word-wrap: break-word;"><b>Low power BOD 2.5 TRIM Value (Write Protect)
</b><br>
This value is used to control LPBOD25 detect voltage level in power-down mode, nominal 2.5 V
<br>
Higher trim value, higher detection voltage.
<br>
Note: These bits are write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[26:24]</td><td>BODDGSEL</td><td><div style="word-wrap: break-word;"><b>Brown-out Detector Output De-glitch Time Select (Write Protect)
</b><br>
000 = BOD output is sampled by RC10K clock.
<br>
001 = 4 system clock (HCLK).
<br>
010 = 8 system clock (HCLK).
<br>
011 = 16 system clock (HCLK).
<br>
100 = 32 system clock (HCLK).
<br>
101 = 64 system clock (HCLK).
<br>
110 = 128 system clock (HCLK).
<br>
111 = 256 system clock (HCLK).
<br>
Note: These bits are write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[30:28]</td><td>LVRDGSEL</td><td><div style="word-wrap: break-word;"><b>LVR Output De-glitch Time Select (Write Protect)
</b><br>
000 = Without de-glitch function.
<br>
001 = 4 system clock (HCLK).
<br>
010 = 8 system clock (HCLK).
<br>
011 = 16 system clock (HCLK).
<br>
100 = 32 system clock (HCLK).
<br>
101 = 64 system clock (HCLK).
<br>
110 = 128 system clock (HCLK).
<br>
111 = 256 system clock (HCLK).
<br>
Note: These bits are write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03205">3205</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a21b93ff188c442c3ad97b3e55b215b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b93ff188c442c3ad97b3e55b215b2b">&#9670;&nbsp;</a></span>GPA_MFPH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPA_MFPH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0034] GPIOA High Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPA_MFPH
</font><br><p> <font size="2">
Offset: 0x34  GPIOA High Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PA8MFP</td><td><div style="word-wrap: break-word;"><b>PA.8 Multi-function Pin Selection
</b><br>
0000 = GPIOA[8]
<br>
0001 = I2C0 data input/output pin.
<br>
0010 = Timer0 external counter input.
<br>
0011 = SmartCard0 clock pin.
<br>
0100 = SPI2 slave select pin.
<br>
0101 = Timer0 toggle output.
<br>
0110 = UART0 Clear to Send input pin.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PA9MFP</td><td><div style="word-wrap: break-word;"><b>PA.9 Multi-function Pin Selection
</b><br>
0000 = GPIOA[9]
<br>
0001 = I2C0 clock pin.
<br>
0010 = Timer1 external counter input.
<br>
0011 = SmartCard0 data pin.
<br>
0100 = SPI0 serial clock pin.
<br>
0101 = Timer1 toggle output.
<br>
0110 = UART1 Request to Send output pin.
<br>
0111 = Snooper pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PA10MFP</td><td><div style="word-wrap: break-word;"><b>PA.10 Multi-function Pin Selection
</b><br>
0000 = GPIOA[10]
<br>
0001 = I2C1 data input/output pin.
<br>
0010 = Timer2 external counter input.
<br>
0011 = SmartCard0 power pin.
<br>
0100 = SPI2 1st MISO (Master In, Slave Out) pin.
<br>
0101 = Timer2 toggle output.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PA11MFP</td><td><div style="word-wrap: break-word;"><b>PA.11 Multi-function Pin Selection
</b><br>
0000 = GPIOA[11]
<br>
0001 = I2C1 clock pin.
<br>
0010 = Timer3 external counter input.
<br>
0011 = SmartCard0 reset pin.
<br>
0100 = SPI2 1st MOSI (Master Out, Slave In) pin.
<br>
0101 = Timer3 toggle output.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>PA12MFP</td><td><div style="word-wrap: break-word;"><b>PA.12 Multi-function Pin Selection
</b><br>
0000 = GPIOA[12]
<br>
0001 = PWM0 channel0 output/capture input.
<br>
0011 = Timer0 capture input.
<br>
0101 = I2C0 data input/output pin.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>PA13MFP</td><td><div style="word-wrap: break-word;"><b>PA.13 Multi-function Pin Selection
</b><br>
0000 = GPIOA[13]
<br>
0001 = PWM0 channel1 output/capture input.
<br>
0011 = Timer1 capture input.
<br>
0101 = I2C0 clock pin.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PA14MFP</td><td><div style="word-wrap: break-word;"><b>PA.14 Multi-function Pin Selection
</b><br>
0000 = GPIOA[14]
<br>
0001 = PWM0 channel2 output/capture input.
<br>
0010 = I2C1 data input/output pin.
<br>
0011 = I2C1 data input/output pin.
<br>
0101 = Timer2 external counter input.
<br>
0110 = Data receiver input pin for UART0.
<br>
0111 = Timer2 toggle output.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PA15MFP</td><td><div style="word-wrap: break-word;"><b>PA.15 Multi-function Pin Selection
</b><br>
0000 = GPIOA[15]
<br>
0001 = PWM0 channel3 output/capture input.
<br>
0010 = I2C1 clock pin.
<br>
0011 = Timer1 capture input.
<br>
0100 = SmartCard0 power pin.
<br>
0110 = Data transmitter output pin for UART0.
<br>
0111 = Timer3 toggle output.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03189">3189</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a9a03e10c205b034173e15b13cf250c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a03e10c205b034173e15b13cf250c54">&#9670;&nbsp;</a></span>GPA_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPA_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0030] GPIOA Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPA_MFPL
</font><br><p> <font size="2">
Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PA0MFP</td><td><div style="word-wrap: break-word;"><b>PA.0 Multi-function Pin Selection
</b><br>
0000 = GPIOA[0]
<br>
0001 = ADC analog input0.
<br>
0010 = Comparator1 P-end input.
<br>
0011 = Timer0 capture input.
<br>
0101 = PWM0 channel2 output/capture input.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PA1MFP</td><td><div style="word-wrap: break-word;"><b>PA.1 Multi-function Pin Selection
</b><br>
0000 = GPIOA[1]
<br>
0001 = ADC analog input1.
<br>
0010 = Comparator1 N-end input.
<br>
0110 = SPI0 2nd MISO (Master In, Slave Out) pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PA2MFP</td><td><div style="word-wrap: break-word;"><b>PA.2 Multi-function Pin Selection
</b><br>
0000 = GPIOA[2]
<br>
0001 = ADC analog input2.
<br>
0101 = Data receiver input pin for UART1.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PA3MFP</td><td><div style="word-wrap: break-word;"><b>PA.3 Multi-function Pin Selection
</b><br>
0000 = GPIOA[3]
<br>
0001 = ADC analog input3.
<br>
0101 = Data transmitter output pin for UART1.
<br>
0110 = SPI3 1st MOSI (Master Out, Slave In) pin.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>PA4MFP</td><td><div style="word-wrap: break-word;"><b>PA.4 Multi-function Pin Selection
</b><br>
0000 = GPIOA[4]
<br>
0001 = ADC analog input4.
<br>
0101 = I2C0 data input/output pin.
<br>
0110 = SPI3 1st MISO (Master In, Slave Out) pin.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>PA5MFP</td><td><div style="word-wrap: break-word;"><b>PA.5 Multi-function Pin Selection
</b><br>
0000 = GPIOA[5]
<br>
0001 = ADC analog input5.
<br>
0101 = I2C0 clock pin.
<br>
0110 = SPI3 serial clock pin.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PA6MFP</td><td><div style="word-wrap: break-word;"><b>PA.6 Multi-function Pin Selection
</b><br>
0000 = GPIOA[6]
<br>
0001 = ADC analog input6.
<br>
0010 = Comparator1 output.
<br>
0011 = Timer3 capture input.
<br>
0100 = Timer3 external counter input.
<br>
0101 = PWM0 channel3 output/capture input.
<br>
0111 = Timer3 toggle output.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03188">3188</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a44b4dcf365ceb2fe570865a5a6d4a0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b4dcf365ceb2fe570865a5a6d4a0e6">&#9670;&nbsp;</a></span>GPB_MFPH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPB_MFPH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x003c] GPIOB High Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPB_MFPH
</font><br><p> <font size="2">
Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PB8MFP</td><td><div style="word-wrap: break-word;"><b>PB.8 Multi-function Pin Selection
</b><br>
0000 = GPIOB[8]
<br>
0001 = ADC external trigger input.
<br>
0010 = Timer0 external counter input.
<br>
0011 = External interrupt0 input pin.
<br>
0100 = Timer0 toggle output.
<br>
0111 = Snooper pin.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PB9MFP</td><td><div style="word-wrap: break-word;"><b>PB.9 Multi-function Pin Selection
</b><br>
0000 = GPIOB[9]
<br>
0001 = SPI1 slave select pin.
<br>
0010 = Timer2 external counter input.
<br>
0100 = Timer2 toggle output.
<br>
0101 = External interrupt0 input pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PB10MFP</td><td><div style="word-wrap: break-word;"><b>PB.10 Multi-function Pin Selection
</b><br>
0000 = GPIOB[10]
<br>
0001 = SPI0 1st MOSI (Master Out, Slave In) pin.
<br>
0100 = Timer2 toggle output.
<br>
0101 = SPI0 slave select pin.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PB11MFP</td><td><div style="word-wrap: break-word;"><b>PB.11 Multi-function Pin Selection
</b><br>
0000 = GPIOB[11]
<br>
0001 = PWM0 channel4 output/capture input.
<br>
0010= Timer3 external counter input.
<br>
0100 = Timer3 toggle output.
<br>
0101 = SPI0 1st MISO (Master In, Slave Out) pin.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>PB13MFP</td><td><div style="word-wrap: break-word;"><b>PB.13 Multi-function Pin Selection
</b><br>
0000 = GPIOB[13]
<br>
0011 = SPI2 2nd MISO (Master In, Slave Out) pin.
<br>
0111 = Snooper pin.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PB14MFP</td><td><div style="word-wrap: break-word;"><b>PB.14 Multi-function Pin Selection
</b><br>
0000 = GPIOB[14]
<br>
0001 = External interrupt0 input pin.
<br>
0011 = SPI2 2nd MOSI (Master Out, Slave In) pin.
<br>
0100 = SPI2 slave select pin.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PB15MFP</td><td><div style="word-wrap: break-word;"><b>PB.15 Multi-function Pin Selection
</b><br>
0000 = GPIOB[15]
<br>
0001 = External interrupt1 input pin.
<br>
0011 = Snooper pin.
<br>
0100 = SmartCard1 card detect pin.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03191">3191</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="af54a1e3222a0f16f98af64069587b636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54a1e3222a0f16f98af64069587b636">&#9670;&nbsp;</a></span>GPB_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPB_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0038] GPIOB Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPB_MFPL
</font><br><p> <font size="2">
Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PB0MFP</td><td><div style="word-wrap: break-word;"><b>PB.0 Multi-function Pin Selection
</b><br>
0000 = GPIOB[0]
<br>
0001 = Data receiver input pin for UART0.
<br>
0011 = SPI1 1st MOSI (Master Out, Slave In) pin.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PB1MFP</td><td><div style="word-wrap: break-word;"><b>PB.1 Multi-function Pin Selection
</b><br>
0000 = GPIOB[1]
<br>
0001 = Data transmitter output pin for UART0.
<br>
0011 = SPI1 1st MISO (Master In, Slave Out) pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PB2MFP</td><td><div style="word-wrap: break-word;"><b>PB.2 Multi-function Pin Selection
</b><br>
0000 = GPIOB[2]
<br>
0001 = UART0 Request to Send output pin.
<br>
0011 = SPI1 serial clock pin.
<br>
0100 = Frequency Divider output pin.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PB3MFP</td><td><div style="word-wrap: break-word;"><b>PB.3 Multi-function Pin Selection
</b><br>
0000 = GPIOB[3]
<br>
0001 = UART0 Clear to Send input pin.
<br>
0011 = SPI1 slave select pin.
<br>
0100 = SmartCard1 card detect pin.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>PB4MFP</td><td><div style="word-wrap: break-word;"><b>PB.4 Multi-function Pin Selection
</b><br>
0000 = GPIOB[4]
<br>
0001 = Data receiver input pin for UART1.
<br>
0011 = SmartCard0 card detect pin.
<br>
0100 = SPI2 slave select pin.
<br>
0110 = RTC 1Hz output.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>PB5MFP</td><td><div style="word-wrap: break-word;"><b>PB.5 Multi-function Pin Selection
</b><br>
0000 = GPIOB[5]
<br>
0001 = Data transmitter output pin for UART1.
<br>
0011 = SmartCard0 reset pin.
<br>
0100 = SPI2 serial clock pin.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PB6MFP</td><td><div style="word-wrap: break-word;"><b>PB.6 Multi-function Pin Selection
</b><br>
0000 = GPIOB[6]
<br>
0001 = UART1 Request to Send output pin.
<br>
0100 = SPI2 1st MISO (Master In, Slave Out) pin.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PB7MFP</td><td><div style="word-wrap: break-word;"><b>PB.7 Multi-function Pin Selection
</b><br>
0000 = GPIOB[7]
<br>
0001 = UART1 Clear to Send input pin.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03190">3190</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="abc41156a35c42847828d926efd65b65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc41156a35c42847828d926efd65b65f">&#9670;&nbsp;</a></span>GPC_MFPH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPC_MFPH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0044] GPIOC High Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPC_MFPH
</font><br><p> <font size="2">
Offset: 0x44  GPIOC High Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PC8MFP</td><td><div style="word-wrap: break-word;"><b>PC.8 Multi-function Pin Selection
</b><br>
0000 = GPIOC[8]
<br>
0001 = SPI1 slave select pin.
<br>
0101 = I2C1 data input/output pin.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PC9MFP</td><td><div style="word-wrap: break-word;"><b>PC.9 Multi-function Pin Selection
</b><br>
0000 = GPIOC[9]
<br>
0001 = SPI1 serial clock pin.
<br>
0101 = I2C1 clock pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PC10MFP</td><td><div style="word-wrap: break-word;"><b>PC.10 Multi-function Pin Selection
</b><br>
0000 = GPIOC[10]
<br>
0001 = SPI0 1st MISO (Master In, Slave Out) pin.
<br>
0101 = Data receiver input pin for UART1.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PC11MFP</td><td><div style="word-wrap: break-word;"><b>PC.11 Multi-function Pin Selection
</b><br>
0000 = GPIOC[11]
<br>
0001 = SPI1 1st MOSI (Master Out, Slave In) pin.
<br>
0101 = Data transmitter output pin for UART1.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PC14MFP</td><td><div style="word-wrap: break-word;"><b>PC.14 Multi-function Pin Selection
</b><br>
0000 = GPIOC[14]
<br>
0001 = UART0 Clear to Send input pin.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PC15MFP</td><td><div style="word-wrap: break-word;"><b>PC.15 Multi-function Pin Selection
</b><br>
0000 = GPIOC[15]
<br>
0001 = UART1 Request to Send output pin.
<br>
0011 = Timer0 capture input.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03193">3193</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="acc350722fe458151421ed6a33471a7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc350722fe458151421ed6a33471a7e8">&#9670;&nbsp;</a></span>GPC_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPC_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0040] GPIOC Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPC_MFPL
</font><br><p> <font size="2">
Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PC0MFP</td><td><div style="word-wrap: break-word;"><b>PC.0 Multi-function Pin Selection
</b><br>
0000 = GPIOC[0]
<br>
0001 = SPI0 slave select pin.
<br>
0100 = SmartCard1 clock pin.
<br>
0101 = PWM0 break1 input 1.
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PC1MFP</td><td><div style="word-wrap: break-word;"><b>PC.1 Multi-function Pin Selection
</b><br>
0000 = GPIOC[1]
<br>
0001 = SPI0 serial clock pin.
<br>
0100 = SmartCard1 data pin.
<br>
0101 = PWM0 break1 input 0.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PC2MFP</td><td><div style="word-wrap: break-word;"><b>PC.2 Multi-function Pin Selection
</b><br>
0000 = GPIOC[2]
<br>
0001 = SPI0 1st MISO (Master In, Slave Out) pin.
<br>
0100 = SmartCard1 power pin.
<br>
0101 = PWM0 break0 input 1.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PC3MFP</td><td><div style="word-wrap: break-word;"><b>PC.3 Multi-function Pin Selection
</b><br>
0000 = GPIOC[3]
<br>
0001 = SPI0 1st MOSI (Master Out, Slave In) pin.
<br>
0100 = SmartCard1 reset pin.
<br>
0101 = PWM0 break0 input 0.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PC6MFP</td><td><div style="word-wrap: break-word;"><b>PC.6 Pin Function Selection
</b><br>
0000 = GPIOC[6]
<br>
0001 = Data receiver input pin for UART1.
<br>
0011 = Timer0 capture input.
<br>
0100 = SmartCard1 card detect pin.
<br>
0101 = PWM0 channel0 output/capture input.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PC7MFP</td><td><div style="word-wrap: break-word;"><b>PC.7 Multi-function Pin Selection
</b><br>
0000 = GPIOC[7]
<br>
0001 = Data transmitter output pin for UART1.
<br>
0010 = ADC analog input7.
<br>
0011 = Timer1 capture input.
<br>
0101 = PWM0 channel1 output/capture input.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03192">3192</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="adb72336a6b365d90b2462a3ba2300c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72336a6b365d90b2462a3ba2300c66">&#9670;&nbsp;</a></span>GPD_MFPH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPD_MFPH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x004c] GPIOD High Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPD_MFPH
</font><br><p> <font size="2">
Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[27:24]</td><td>PD14MFP</td><td><div style="word-wrap: break-word;"><b>PD.14 Multi-function Pin Selection
</b><br>
0000 = GPIOD[14]
<br>
0001 = SPI0 2nd MOSI (Master Out, Slave In) pin.
<br>
</div></td></tr><tr><td>
[30:28]</td><td>PD15MFP</td><td><div style="word-wrap: break-word;"><b>PD.15 Multi-function Pin Selection
</b><br>
0000 = GPIOD[15]
<br>
0001 = SPI0 2nd MISO (Master In, Slave Out) pin.
<br>
0100 = SmartCard1 clock pin.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03195">3195</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a955475a9fe10d5a8b98cd8a509c21f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955475a9fe10d5a8b98cd8a509c21f9b">&#9670;&nbsp;</a></span>GPD_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPD_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0048] GPIOD Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPD_MFPL
</font><br><p> <font size="2">
Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[27:24]</td><td>PD6MFP</td><td><div style="word-wrap: break-word;"><b>PD.6 Multi-function Pin Selection
</b><br>
0000 = GPIOD[6]
<br>
0011 = SPI1 2nd MOSI (Master Out, Slave In) pin.
<br>
0100 = SmartCard1 reset pin.
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PD7MFP</td><td><div style="word-wrap: break-word;"><b>PD.7 Multi-function Pin Selection
</b><br>
0000 = GPIOD[7]
<br>
0011 = SPI1 2nd MISO (Master In, Slave Out) pin.
<br>
0100 = SmartCard1 power pin.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03194">3194</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a78c990a849c14895d01f3c090c5062a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c990a849c14895d01f3c090c5062a2">&#9670;&nbsp;</a></span>GPE_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPE_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0050] GPIOE Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPE_MFPL
</font><br><p> <font size="2">
Offset: 0x50  GPIOE Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[23:20]</td><td>PE5MFP</td><td><div style="word-wrap: break-word;"><b>PE.5 Multi-function Pin Selection
</b><br>
0000 = GPIOE[5]
<br>
0001 = PWM0 channel5 output/capture input.
<br>
0110 = RTC 1Hz output.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03196">3196</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="af03540e23beda3a30fe90e9aa839368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03540e23beda3a30fe90e9aa839368b">&#9670;&nbsp;</a></span>GPF_MFPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::GPF_MFPL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0058] GPIOF Low Byte Multiple Function Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">GPF_MFPL
</font><br><p> <font size="2">
Offset: 0x58  GPIOF Low Byte Multiple Function Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>PF0MFP</td><td><div style="word-wrap: break-word;"><b>PF.0 Multi-function Pin Selection
</b><br>
0000 = GPIOF[1]
<br>
0101 = External interrupt0 input pin.
<br>
X111 = Serial wired debugger data pin
<br>
</div></td></tr><tr><td>
[7:4]</td><td>PF1MFP</td><td><div style="word-wrap: break-word;"><b>PF.1 Multi-function Pin Selection
</b><br>
0000 = GPIOF[1]
<br>
0100 = Frequency Divider output pin.
<br>
0101 = External interrupt1 input pin.
<br>
X111 = Serial wired debugger clock pin.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>PF2MFP</td><td><div style="word-wrap: break-word;"><b>PF.2 Multi-function Pin Selection
</b><br>
0000 = GPIOF[2]
<br>
X111 = External 4~36 MHz (high speed) crystal output pin.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>PF3MFP</td><td><div style="word-wrap: break-word;"><b>PF.3 Multi-function Pin Selection
</b><br>
0000 = GPIOF[3]
<br>
X111 = External 4~36 MHz (high speed) crystal input pin.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>PF6MFP</td><td><div style="word-wrap: break-word;"><b>PF.6 Multi-function Pin Selection
</b><br>
0000 = GPIOF[6]
<br>
0001 = I2C1 data input/output pin.
<br>
X111 = External 32.768 kHz crystal output pin(default).
<br>
</div></td></tr><tr><td>
[31:28]</td><td>PF7MFP</td><td><div style="word-wrap: break-word;"><b>PF.7 Multi-function Pin Selection
</b><br>
0000 = GPIOF[7]
<br>
0001 = I2C1 clock pin.
<br>
0011 = SmartCard0 card detect pin.
<br>
X111 = External 32.768 kHz crystal input pin(default).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03200">3200</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="af8683a6bf8116c92108bbb38385942e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8683a6bf8116c92108bbb38385942e0">&#9670;&nbsp;</a></span>IPRST1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IPRST1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0008] Peripheral Reset Control Resister1</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IPRST1
</font><br><p> <font size="2">
Offset: 0x08  Peripheral Reset Control Resister1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CHIPRST</td><td><div style="word-wrap: break-word;"><b>Chip One-shot Reset (Write Protect)
</b><br>
Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
<br>
The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
<br>
About the difference between CHIPRST and SYSRESETREQ(AIRCR[2]), please refer to section 6.2.2
<br>
0 = Chip normal operation.
<br>
1 = Chip one-shot reset.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>CPURST</td><td><div style="word-wrap: break-word;"><b>Processor Core One-shot Reset (Write Protect)
</b><br>
Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
<br>
0 = Processor core normal operation.
<br>
1 = Processor core one-shot reset.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[2]</td><td>PDMARST</td><td><div style="word-wrap: break-word;"><b>PDMA Controller Reset (Write Protect)
</b><br>
Setting this bit to 1 will generate a reset signal to the PDMA
<br>
User needs to set this bit to 0 to release from reset state.
<br>
0 = PDMA controller normal operation.
<br>
1 = PDMA controller reset.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03171">3171</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a15fba5658eb489848ce7e205bb20cf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fba5658eb489848ce7e205bb20cf4f">&#9670;&nbsp;</a></span>IPRST2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IPRST2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x000c] Peripheral Reset Control Resister2</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IPRST2
</font><br><p> <font size="2">
Offset: 0x0C  Peripheral Reset Control Resister2
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>GPIORST</td><td><div style="word-wrap: break-word;"><b>GPIO Controller Reset
</b><br>
0 = GPIO module normal operation.
<br>
1 = GPIO module reset.
<br>
</div></td></tr><tr><td>
[2]</td><td>TMR0RST</td><td><div style="word-wrap: break-word;"><b>Timer0 Controller Reset
</b><br>
0 = Timer0 module normal operation.
<br>
1 = Timer0 module reset.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR1RST</td><td><div style="word-wrap: break-word;"><b>Timer1 Controller Reset
</b><br>
0 = Timer1 module normal operation.
<br>
1 = Timer1 module reset.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR2RST</td><td><div style="word-wrap: break-word;"><b>Timer2 Controller Reset
</b><br>
0 = Timer2 module normal operation.
<br>
1 = Timer2 module reset.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR3RST</td><td><div style="word-wrap: break-word;"><b>Timer3 Controller Reset
</b><br>
0 = Timer3 module normal operation.
<br>
1 = Timer3 module reset.
<br>
</div></td></tr><tr><td>
[8]</td><td>I2C0RST</td><td><div style="word-wrap: break-word;"><b>I2C0 Controller Reset
</b><br>
0 = I2C0 module normal operation.
<br>
1 = I2C0 module reset.
<br>
</div></td></tr><tr><td>
[9]</td><td>I2C1RST</td><td><div style="word-wrap: break-word;"><b>I2C1 Controller Reset
</b><br>
0 = I2C1 module normal operation.
<br>
1 = I2C1 module reset.
<br>
</div></td></tr><tr><td>
[12]</td><td>SPI0RST</td><td><div style="word-wrap: break-word;"><b>SPI0 Controller Reset
</b><br>
0 = SPI0 module normal operation.
<br>
1 = SPI0 module reset.
<br>
</div></td></tr><tr><td>
[13]</td><td>SPI1RST</td><td><div style="word-wrap: break-word;"><b>SPI1 Controller Reset
</b><br>
0 = SPI1 module normal operation.
<br>
1 = SPI1 module reset.
<br>
</div></td></tr><tr><td>
[14]</td><td>SPI2RST</td><td><div style="word-wrap: break-word;"><b>SPI2 Controller Reset
</b><br>
0 = SPI2 module normal operation.
<br>
1 = SPI2 module reset.
<br>
</div></td></tr><tr><td>
[15]</td><td>SPI3RST</td><td><div style="word-wrap: break-word;"><b>SPI3 Controller Reset
</b><br>
0 = SPI3 module normal operation.
<br>
1 = SPI3 module reset.
<br>
</div></td></tr><tr><td>
[16]</td><td>UART0RST</td><td><div style="word-wrap: break-word;"><b>UART0 Controller Reset
</b><br>
0 = UART0 module normal operation.
<br>
1 = UART0 module reset.
<br>
</div></td></tr><tr><td>
[17]</td><td>UART1RST</td><td><div style="word-wrap: break-word;"><b>UART1 Controller Reset
</b><br>
0 = UART1 module normal operation.
<br>
1 = UART1 module reset.
<br>
</div></td></tr><tr><td>
[20]</td><td>PWM0RST</td><td><div style="word-wrap: break-word;"><b>PWM0 Controller Reset
</b><br>
0 = PWM0 module normal operation.
<br>
1 = PWM0 module reset.
<br>
</div></td></tr><tr><td>
[22]</td><td>ACMP01RST</td><td><div style="word-wrap: break-word;"><b>Comparator Controller Reset
</b><br>
0 = Comparator module normal operation.
<br>
1 = Comparator module reset.
<br>
</div></td></tr><tr><td>
[28]</td><td>ADCRST</td><td><div style="word-wrap: break-word;"><b>ADC Controller Reset
</b><br>
0 = ADC module normal operation.
<br>
1 = ADC module reset.
<br>
</div></td></tr><tr><td>
[30]</td><td>SC0RST</td><td><div style="word-wrap: break-word;"><b>SmartCard 0 Controller Reset
</b><br>
0 = SmartCard module normal operation.
<br>
1 = SmartCard module reset.
<br>
</div></td></tr><tr><td>
[31]</td><td>SC1RST</td><td><div style="word-wrap: break-word;"><b>SmartCard1 Controller Reset
</b><br>
0 = SmartCard module normal operation.
<br>
1 = SmartCard module reset.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03172">3172</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aa7cd396a53f67020d7e8c287ac28092a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd396a53f67020d7e8c287ac28092a">&#9670;&nbsp;</a></span>IRC0TCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC0TCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0080] HIRC0 Trim Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC0TCTL
</font><br><p> <font size="2">
Offset: 0x80  HIRC0 Trim Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[2:0]</td><td>FREQSEL</td><td><div style="word-wrap: break-word;"><b>Trim Frequency Selection
</b><br>
This field indicates the target frequency of 12 MHz internal high speed RC oscillator (HIRC0) auto trim.
<br>
During auto trim operation, if clock error detected with CESTOPEN (SYS_IRC0TCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 000 automatically.
<br>
000 = Disable HIRC0 auto trim function.
<br>
001 = Enable HIRC0 auto trim function and trim HIRC to 11.0592 MHz.
<br>
010 = Enable HIRC0 auto trim function and trim HIRC to 12 MHz.
<br>
011 = Enable HIRC0 auto trim function and trim HIRC to 12.288 MHz.
<br>
100 = Enable HIRC0 auto trim function and trim HIRC to 16 MHz.
<br>
Note: HIRC0 auto trim cannot work normally at power down mode
<br>
These bits must be cleared before entering power down mode.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>LOOPSEL</td><td><div style="word-wrap: break-word;"><b>Trim Calculation Loop Selection
</b><br>
This field defines that trim value calculation is based on how many 32.768 kHz clock.
<br>
00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
<br>
01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
<br>
10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
<br>
11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
<br>
Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RETRYCNT</td><td><div style="word-wrap: break-word;"><b>Trim Value Update Limitation Count
</b><br>
This field defines that how many times the auto trim circuit will try to update the HIRC0 trim value before the frequency of HIRC0 locked.
<br>
Once the HIRC0 locked, the internal trim value update counter will be reset.
<br>
If the trim value update counter reached this limitation value and frequency of HIRC0 still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_IRC0TCTL[1:0]) will be cleared to 00.
<br>
00 = Trim retry count limitation is 64 loops.
<br>
01 = Trim retry count limitation is 128 loops.
<br>
10 = Trim retry count limitation is 256 loops.
<br>
11 = Trim retry count limitation is 512 loops.
<br>
</div></td></tr><tr><td>
[8]</td><td>CESTOPEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Stop Enable Bit
</b><br>
This bit is used to control if stop the HIRC0 trim operation when 32.768 kHz clock error is detected.
<br>
If set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC0TISTS[2]) would be set high and HIRC0 trim operation was stopped
<br>
If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC0TISTS[2]) would be set high and HIRC0 trim operation is continuously.
<br>
0 = The trim operation is keep going if clock is inaccuracy.
<br>
1 = The trim operation is stopped if clock is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03216">3216</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aa92fafebe5cf5b0d1f04ee4083ca0b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92fafebe5cf5b0d1f04ee4083ca0b3f">&#9670;&nbsp;</a></span>IRC0TIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC0TIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0084] HIRC0 Trim Interrupt Enable Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC0TIEN
</font><br><p> <font size="2">
Offset: 0x84  HIRC0 Trim Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TFAILIEN</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Enable Bit
</b><br>
This bit controls if an interrupt will be triggered while HIRC0 trim value update limitation count reached and HIRC0 frequency still not locked on target frequency set by FREQSEL (SYS_IRC0TCTL[1:0]).
<br>
If this bit is high and TFAILIF (SYS_IRC0TSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.
<br>
0 = Disable TFAILIF (SYS_IRC0TSTS[1]) status to trigger an interrupt to CPU.
<br>
1 = Enable TFAILIF (SYS_IRC0TSTS[1]) status to trigger an interrupt to CPU.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKEIEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Enable Bit
</b><br>
This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
<br>
If this bit is set to1, and CLKERRIF (SYS_IRC0TSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
<br>
0 = Disable CLKERRIF (SYS_IRC0TSTS[2]) status to trigger an interrupt to CPU.
<br>
1 = Enable CLKERRIF (SYS_IRC0TSTS[2]) status to trigger an interrupt to CPU.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03217">3217</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="abc7a286d6b10543711649f6e000af9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7a286d6b10543711649f6e000af9b8">&#9670;&nbsp;</a></span>IRC0TISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC0TISTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0088] HIRC0 Trim Interrupt Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC0TISTS
</font><br><p> <font size="2">
Offset: 0x88  HIRC0 Trim Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>FREQLOCK</td><td><div style="word-wrap: break-word;"><b>HIRC0 Frequency Lock Status
</b><br>
This bit indicates the HIRC0 frequency is locked.
<br>
This is a status bit and doesn't trigger any interrupt.
<br>
0 = The internal high-speed oscillator frequency doesn't lock at frequency set by FREQSEL (SYS_IRC0TCTL[2:0]).
<br>
1 = The internal high-speed oscillator frequency locked at frequency set by FREQSEL (SYS_IRC0TCTL[2:0]).
<br>
</div></td></tr><tr><td>
[1]</td><td>TFAILIF</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Status
</b><br>
This bit indicates that HIRC0 trim value update limitation count reached and the HIRC0 clock frequency still doesn't be locked
<br>
Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRC0TCTL[1:0]) will be cleared to 00 by hardware automatically.
<br>
If this bit is set and TFAILIEN (SYS_IRC0TIEN[1]) is high, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached
<br>
Write 1 to clear this to 0.
<br>
0 = Trim value update limitation count does not reach.
<br>
1 = Trim value update limitation count reached and HIRC frequency still not locked.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKERRIF</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Status
</b><br>
When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or internal high speed RC oscillator (HIRC0) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
<br>
Once this bit is set to 1, the auto trim operation stopped and FREQSEL (SYS_IRC0TCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN (SYS_IRC0TCTL[8]) is set to 1.
<br>
If this bit is set and CLKEIEN (SYS_IRC0TIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy
<br>
Write 1 to clear this to 0.
<br>
0 = Clock frequency is accuracy.
<br>
1 = Clock frequency is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03218">3218</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a158f979f2a85d5a38ffe8f7f8bd43374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158f979f2a85d5a38ffe8f7f8bd43374">&#9670;&nbsp;</a></span>IRC1TCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC1TCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0090] HIRC1 Trim Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC1TCTL
</font><br><p> <font size="2">
Offset: 0x90  HIRC1 Trim Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>FREQSEL</td><td><div style="word-wrap: break-word;"><b>Trim Frequency Selection
</b><br>
This field indicates the target frequency of 36 MHz internal high speed RC oscillator (HIRC1) auto trim.
<br>
During auto trim operation, if clock error detected with CESTOPEN (SYS_IRC1TCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
<br>
00 = Disable HIRC1 auto trim function.
<br>
01 = Reserved
<br>
10 = Enable HIRC1 auto trim function and trim HIRC to 36 MHz.
<br>
11 = Reserved.
<br>
Note: HIRC1 auto trim cannot work normally at power down mode
<br>
These bits must be cleared before entering power down mode.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>LOOPSEL</td><td><div style="word-wrap: break-word;"><b>Trim Calculation Loop Selection
</b><br>
This field defines that trim value calculation is based on how many 32.768 kHz clock.
<br>
00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
<br>
01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
<br>
10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
<br>
11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
<br>
Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RETRYCNT</td><td><div style="word-wrap: break-word;"><b>Trim Value Update Limitation Count
</b><br>
This field defines that how many times the auto trim circuit will try to update the HIRC1 trim value before the frequency of HIRC1 locked.
<br>
Once the HIRC1 locked, the internal trim value update counter will be reset.
<br>
If the trim value update counter reached this limitation value and frequency of HIRC1 still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_IRC1TCTL[1:0]) will be cleared to 00.
<br>
00 = Trim retry count limitation is 64 loops.
<br>
01 = Trim retry count limitation is 128 loops.
<br>
10 = Trim retry count limitation is 256 loops.
<br>
11 = Trim retry count limitation is 512 loops.
<br>
</div></td></tr><tr><td>
[8]</td><td>CESTOPEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Stop Enable Bit
</b><br>
This bit is used to control if stop the HIRC1 trim operation when 32.768 kHz clock error is detected.
<br>
If set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC1TISTS[2]) would be set high and HIRC1 trim operation was stopped
<br>
If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC1TISTS[2]) would be set high and HIRC1 trim operation is continuously.
<br>
0 = The trim operation is keep going if clock is inaccuracy.
<br>
1 = The trim operation is stopped if clock is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03222">3222</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a25031d660098c457d75c0fc35435c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25031d660098c457d75c0fc35435c898">&#9670;&nbsp;</a></span>IRC1TIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC1TIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0094] HIRC1 Trim Interrupt Enable Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC1TIEN
</font><br><p> <font size="2">
Offset: 0x94  HIRC1 Trim Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TFAILIEN</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Enable Bit
</b><br>
This bit controls if an interrupt will be triggered while HIRC1 trim value update limitation count reached and HIRC1 frequency still not locked on target frequency set by FREQSEL (SYS_IRC1TCTL[1:0]).
<br>
If this bit is high and TFAILIF (SYS_IRC1TSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.
<br>
0 = Disable TFAILIF (SYS_IRC1TSTS[1]) status to trigger an interrupt to CPU.
<br>
1 = Enable TFAILIF (SYS_IRC1TSTS[1]) status to trigger an interrupt to CPU.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKEIEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Enable Bit
</b><br>
This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
<br>
If this bit is set to1, and CLKERRIF (SYS_IRC1TSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
<br>
0 = Disable CLKERRIF (SYS_IRC1TSTS[2]) status to trigger an interrupt to CPU.
<br>
1 = Enable CLKERRIF (SYS_IRC1TSTS[2]) status to trigger an interrupt to CPU.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03223">3223</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a45400d7eda37292ca9e0437de46ed2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45400d7eda37292ca9e0437de46ed2ed">&#9670;&nbsp;</a></span>IRC1TISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IRC1TISTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0098] HIRC1 Trim Interrupt Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRC1TISTS
</font><br><p> <font size="2">
Offset: 0x98  HIRC1 Trim Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>FREQLOCK</td><td><div style="word-wrap: break-word;"><b>HIRC1 Frequency Lock Status
</b><br>
This bit indicates the HIRC1 frequency is locked.
<br>
This is a status bit and doesn't trigger any interrupt.
<br>
0 = The internal high-speed oscillator frequency doesn't lock at 36 MHz yet.
<br>
1 = The internal high-speed oscillator frequency locked at 36 MHz.
<br>
</div></td></tr><tr><td>
[1]</td><td>TFAILIF</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Status
</b><br>
This bit indicates that HIRC1 trim value update limitation count reached and the HIRC1 clock frequency still doesn't be locked
<br>
Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRC1TCTL[1:0]) will be cleared to 00 by hardware automatically.
<br>
If this bit is set and TFAILIEN (SYS_IRC1TIEN[1]) is high, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached
<br>
Write 1 to clear this to 0.
<br>
0 = Trim value update limitation count does not reach.
<br>
1 = Trim value update limitation count reached and HIRC1 frequency still not locked.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKERRIF</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Status
</b><br>
When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 36 MHz internal high speed RC oscillator (HIRC1) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
<br>
Once this bit is set to 1, the auto trim operation stopped and FREQSEL (SYS_IRC1TCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN (SYS_IRC1TCTL[8]) is set to 1.
<br>
If this bit is set and CLKEIEN (SYS_IRC1TIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy
<br>
Write 1 to clear this to 0.
<br>
0 = Clock frequency is accuracy.
<br>
1 = Clock frequency is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03224">3224</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a3e7f9d4af3099e638570526cb6f40288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7f9d4af3099e638570526cb6f40288">&#9670;&nbsp;</a></span>IVREFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::IVREFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x006c] Internal Voltage Reference Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IVREFCTL
</font><br><p> <font size="2">
Offset: 0x6C  Internal Voltage Reference Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BGPEN</td><td><div style="word-wrap: break-word;"><b>Band-gap Enable Control (Write Protect)
</b><br>
This is a protected register. Please refer to open lock sequence to program it.
<br>
Band-gap is the reference voltage of internal reference voltage
<br>
User must enable band-gap if want to enable internal 1.5, 1.8V or 2.5V reference voltage.
<br>
0 = Disabled.
<br>
1 = Enabled.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>REGEN</td><td><div style="word-wrap: break-word;"><b>Regulator Enable Control (Write Protect)
</b><br>
Enable internal 1.5, 1.8V or 2.5V reference voltage.
<br>
This is a protected register. Please refer to open lock sequence to program it.
<br>
0 = Disabled.
<br>
1 = Enabled.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>SEL25</td><td><div style="word-wrap: break-word;"><b>Regulator Output Voltage Selection (Write Protect)
</b><br>
Select internal reference voltage level.
<br>
00 = 1.5V.
<br>
01 = 1.8V.
<br>
10 = 2.5V.
<br>
11 = 2.5V.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[4]</td><td>EXTMODE</td><td><div style="word-wrap: break-word;"><b>Regulator External Mode (Write Protect)
</b><br>
Users can output regulator output voltage in VREF pin if EXT_MODE is high.
<br>
0 = No connection with external VREF pin.
<br>
1 = Connect to external VREF pin
<br>
Connect a 1uF to 10uF capacitor to AVSS will let internal voltage reference be more stable.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>VREFTRIM</td><td><div style="word-wrap: break-word;"><b>Internal Voltage Reference Trim (Write Protect)
</b><br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03209">3209</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a8c650811df004c108b12713f305990cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c650811df004c108b12713f305990cf">&#9670;&nbsp;</a></span>LDOCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::LDOCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0070] LDO Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LDOCTL
</font><br><p> <font size="2">
Offset: 0x70  LDO Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>FASTWK</td><td><div style="word-wrap: break-word;"><b>Fast Wakeup Control Bit (Write Protect)
</b><br>
0 = Fast Wakeup from Power-Down mode Disabled.
<br>
1 = Fast Wakeup from Power-Down mode Enabled
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>LDOLVL</td><td><div style="word-wrap: break-word;"><b>LDO Output Voltage Select (Write Protect)
</b><br>
00 = 1.2V.
<br>
01 = 1.6V.
<br>
10 = 1.8V.
<br>
11 = 1.8V.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[4]</td><td>LPRMEN</td><td><div style="word-wrap: break-word;"><b>Low-Power Run Mode Enable Bit (Write Protect)
</b><br>
0 = Low-Power run mode Enabled.
<br>
1 = Low-Power run mode Disabled.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[5]</td><td>FMCLVEN</td><td><div style="word-wrap: break-word;"><b>Flash memory Low voltage Mode Enable Bit (Write Protect)
</b><br>
0 = Flash memory low voltage(1.2V) mode Enabled.
<br>
1 = Flash memory low voltage(1.2V) mode Disabled.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03210">3210</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a35c24b30f6065a4c23ec0231b964b90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c24b30f6065a4c23ec0231b964b90b">&#9670;&nbsp;</a></span>MIRCTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::MIRCTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x00a0] MIRC Trim Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MIRCTCTL
</font><br><p> <font size="2">
Offset: 0xA0  MIRC Trim Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>FREQSEL</td><td><div style="word-wrap: break-word;"><b>Trim Frequency Selection
</b><br>
This field indicates the target frequency of 4 MHz internal medium speed RC oscillator (MIRC) auto trim.
<br>
During auto trim operation, if clock error detected with CESTOPEN (SYS_MIRCTCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
<br>
00 = Disable MIRC auto trim function.
<br>
01 = Reserved.
<br>
10 = Enable MIRC auto trim function and trim HIRC to 4 MHz.
<br>
11 = Reserved.
<br>
Note: MIRC auto trim cannot work normally at power down mode
<br>
These bits must be cleared before entering power down mode.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>LOOPSEL</td><td><div style="word-wrap: break-word;"><b>Trim Calculation Loop Selection
</b><br>
This field defines that trim value calculation is based on how many 32.768 kHz clock.
<br>
00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
<br>
01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
<br>
10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
<br>
11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
<br>
Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RETRYCNT</td><td><div style="word-wrap: break-word;"><b>Trim Value Update Limitation Count
</b><br>
This field defines that how many times the auto trim circuit will try to update the MIRC trim value before the frequency of MIRC locked.
<br>
Once the MIRC locked, the internal trim value update counter will be reset.
<br>
If the trim value update counter reached this limitation value and frequency of MIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_MIRCTCTL[1:0]) will be cleared to 00.
<br>
00 = Trim retry count limitation is 64 loops.
<br>
01 = Trim retry count limitation is 128 loops.
<br>
10 = Trim retry count limitation is 256 loops.
<br>
11 = Trim retry count limitation is 512 loops.
<br>
</div></td></tr><tr><td>
[8]</td><td>CESTOPEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Stop Enable Bit
</b><br>
This bit is used to control if stop the MIRC trim operation when 32.768 kHz clock error is detected.
<br>
If set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_MIRCTISTS[2]) would be set high and MIRC trim operation was stopped
<br>
If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_MIRCTISTS[2]) would be set high and MIRC trim operation is continuously.
<br>
0 = The trim operation is keep going if clock is inaccuracy.
<br>
1 = The trim operation is stopped if clock is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03228">3228</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a5b7220555456cd728a11cf1211a07a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7220555456cd728a11cf1211a07a60">&#9670;&nbsp;</a></span>MIRCTIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::MIRCTIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x00a4] MIRC Trim Interrupt Enable Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MIRCTIEN
</font><br><p> <font size="2">
Offset: 0xA4  MIRC Trim Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TFAILIEN</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Enable Bit
</b><br>
This bit controls if an interrupt will be triggered while MIRC trim value update limitation count reached and MIRC frequency still not locked on target frequency set by FREQSEL (SYS_MIRCTCTL[1:0]).
<br>
If this bit is high and TFAILIF (SYS_MIRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that MIRC trim value update limitation count was reached.
<br>
0 = Disable TFAILIF (SYS_MIRCTSTS[1]) status to trigger an interrupt to CPU.
<br>
1 = Enable TFAILIF (SYS_MIRCTSTS[1]) status to trigger an interrupt to CPU.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKEIEN</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Enable Bit
</b><br>
This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
<br>
If this bit is set to1, and CLKERRIF (SYS_MIRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
<br>
0 = Disable CLKERRIF (SYS_MIRCTSTS[2]) status to trigger an interrupt to CPU.
<br>
1 = Enable CLKERRIF (SYS_MIRCTSTS[2]) status to trigger an interrupt to CPU.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03229">3229</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a420a4c8e158647c949a51d2b8752906a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420a4c8e158647c949a51d2b8752906a">&#9670;&nbsp;</a></span>MIRCTISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::MIRCTISTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x00a8] MIRC Trim Interrupt Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MIRCTISTS
</font><br><p> <font size="2">
Offset: 0xA8  MIRC Trim Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>FREQLOCK</td><td><div style="word-wrap: break-word;"><b>MIRC Frequency Lock Status
</b><br>
This bit indicates the MIRC frequency is locked.
<br>
This is a status bit and doesn't trigger any interrupt.
<br>
0 = The internal medium-speed oscillator frequency doesn't lock at 4 MHz yet.
<br>
1 = The internal medium-speed oscillator frequency locked at 4 MHz.
<br>
</div></td></tr><tr><td>
[1]</td><td>TFAILIF</td><td><div style="word-wrap: break-word;"><b>Trim Failure Interrupt Status
</b><br>
This bit indicates that MIRC trim value update limitation count reached and the MIRC clock frequency still doesn't be locked
<br>
Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_MIRCTCTL[1:0]) will be cleared to 00 by hardware automatically.
<br>
If this bit is set and TFAILIEN (SYS_MIRCTIEN[1]) is high, an interrupt will be triggered to notify that MIRC trim value update limitation count was reached
<br>
Write 1 to clear this to 0.
<br>
0 = Trim value update limitation count does not reach.
<br>
1 = Trim value update limitation count reached and MIRC frequency still not locked.
<br>
</div></td></tr><tr><td>
[2]</td><td>CLKERRIF</td><td><div style="word-wrap: break-word;"><b>Clock Error Interrupt Status
</b><br>
When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 4 MHz internal medium speed RC oscillator (MIRC) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
<br>
Once this bit is set to 1, the auto trim operation stopped and FREQSEL (SYS_MIRCTCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN (SYS_MIRCTCTL[8]) is set to 1.
<br>
If this bit is set and CLKEIEN (SYS_MIRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy
<br>
Write 1 to clear this to 0.
<br>
0 = Clock frequency is accuracy.
<br>
1 = Clock frequency is inaccuracy.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03230">3230</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a89ba209e495bff5db1de35a39411cd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ba209e495bff5db1de35a39411cd68">&#9670;&nbsp;</a></span>MISCCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::MISCCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0014] Miscellaneous Control Resister</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MISCCTL
</font><br><p> <font size="2">
Offset: 0x0C  Miscellaneous Control Resister
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[6]</td><td>POR33DIS</td><td><div style="word-wrap: break-word;"><b>POR 33 Disable
</b><br>
0 = POR33 is enable in normal operation.
<br>
1 = POR33 is disable in normal operation.
<br>
</div></td></tr><tr><td>
[7]</td><td>POR18DIS</td><td><div style="word-wrap: break-word;"><b>POR 18 Disable
</b><br>
0 = POR18 is enable in normal operation.
<br>
1 = POR18 is disable in normal operation.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03176">3176</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a98c44c630b54e2df3bf779fca81ff37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c44c630b54e2df3bf779fca81ff37e">&#9670;&nbsp;</a></span>PDID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::PDID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0000] Part Device Identification Number Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PDID
</font><br><p> <font size="2">
Offset: 0x00  Part Device Identification Number Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>PDID</td><td><div style="word-wrap: break-word;"><b>Part Device Identification Number (Read Only)
</b><br>
This register reflects device part number code
<br>
Software can read this register to identify which device is used.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03169">3169</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a58c4205ce6e8c27ddaca0493c99cdda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c4205ce6e8c27ddaca0493c99cdda5">&#9670;&nbsp;</a></span>PORCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::PORCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0060] Power-On-Reset Controller Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PORCTL
</font><br><p> <font size="2">
Offset: 0x60  Power-On-Reset Controller Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>POROFF</td><td><div style="word-wrap: break-word;"><b>Power-on Reset Enable Bit (Write Protect)
</b><br>
When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again
<br>
User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
<br>
The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
<br>
nRESET, Watchdog, BOD reset, ICE reset command and the software-chip reset function.
<br>
Note: This bit is write protected. Refer to the SYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03204">3204</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a74b163f7063651f55407b0565f0a0294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b163f7063651f55407b0565f0a0294">&#9670;&nbsp;</a></span>RCCFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::RCCFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0028] RC Clock Filter Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RCCFCTL
</font><br><p> <font size="2">
Offset: 0x28  RC Clock Filter Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>HIRC0FEN</td><td><div style="word-wrap: break-word;"><b>HIRC0 Clock Filter Enable Bit
</b><br>
This bit is used to enable/disable HIRC0 clock filter function.
<br>
0 = HIRC0 clock filter function Disabled.
<br>
1 = HIRC0 clock filter function Enabled (default).
<br>
</div></td></tr><tr><td>
[1]</td><td>HIRC1FEN</td><td><div style="word-wrap: break-word;"><b>HIRC1 Clock Filter Enable Bit
</b><br>
This bit is used to enable/disable HIRC1 clock filter function.
<br>
0 = HIRC1 clock filter function Disabled.
<br>
1 = HIRC1 clock filter function Enabled (default).
<br>
</div></td></tr><tr><td>
[2]</td><td>MRCFEN</td><td><div style="word-wrap: break-word;"><b>MRC Clock Filter Enable Bit
</b><br>
This bit is used to enable/disable MRC clock filter function.
<br>
0 = 4MHz MRC clock filter function Disabled.
<br>
1 = 4MHz MRC clock filter function Enabled (default).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03184">3184</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a197e4fed077b77ad85d90e67954bfb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197e4fed077b77ad85d90e67954bfb2c">&#9670;&nbsp;</a></span>REGLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::REGLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0100] Register Lock Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">REGLCTL
</font><br><p> <font size="2">
Offset: 0x100  Register Lock Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>REGLCTL</td><td><div style="word-wrap: break-word;"><b>Register Lock Control Code (Write Only)
</b><br>
Some registers have write-protection function
<br>
Writing these registers have to disable the protected function by writing the sequence value 59h, 16h, 88h to this field
<br>
After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
<br>
Register Lock Control Disable Index (Read Only)
<br>
0 = Write-protection Enabled for writing protected registers
<br>
Any write to the protected register is ignored.
<br>
1 = Write-protection Disabled for writing protected registers.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03234">3234</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a73e788e5913f7ec9d0032950ce7af206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e788e5913f7ec9d0032950ce7af206">&#9670;&nbsp;</a></span>RPDBCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::RPDBCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0120] Reset Pin Debounce Clock Selection Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RPDBCLK
</font><br><p> <font size="2">
Offset: 0x120  Reset Pin Debounce Clock Selection Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[6]</td><td>RSTPDBCLK</td><td><div style="word-wrap: break-word;"><b>Reset Pin Debounce Clock Selection Bit
</b><br>
Before switch clock, both clock sources must be enabled.
<br>
0 = MIRC  is selected as reset pin debounce clock.
<br>
1 = HIRC0 is selected as reset pin debounce clock.(default)
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03238">3238</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a378aa7441637420df17bde686e165770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378aa7441637420df17bde686e165770">&#9670;&nbsp;</a></span>RSTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::RSTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0004] System Reset Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RSTSTS
</font><br><p> <font size="2">
Offset: 0x04  System Reset Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PORF</td><td><div style="word-wrap: break-word;"><b>POR Reset Flag
</b><br>
The POR reset flag is set by the Reset Signal from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
<br>
0 = No reset from POR or CHIPRST.
<br>
1 = Power-on Reset (POR) or CHIPRST had issued the reset signal to reset the system.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[1]</td><td>PINRF</td><td><div style="word-wrap: break-word;"><b>NRESET Pin Reset Flag
</b><br>
The nRESET pin reset flag is set by the Reset Signal from the nRESET Pin to indicate the previous reset source.
<br>
0 = No reset from nRESET pin.
<br>
1 = Pin nRESET had issued the reset signal to reset the system.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[2]</td><td>WDTRF</td><td><div style="word-wrap: break-word;"><b>WDT Reset Flag
</b><br>
The WDT reset flag is set by the Reset Signal from the Watchdog Timer to indicate the previous reset source.
<br>
0 = No reset from watchdog timer or window watchdog timer.
<br>
1 = The watchdog timer had issued the reset signal to reset the system.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[3]</td><td>LVRF</td><td><div style="word-wrap: break-word;"><b>LVR Reset Flag
</b><br>
The LVR reset flag is set by the Reset Signal from the Low-Voltage Reset controller to indicate the previous reset source.
<br>
0 = No reset from LVR.
<br>
1 = The LVR had issued the reset signal to reset the system.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[4]</td><td>BODRF</td><td><div style="word-wrap: break-word;"><b>BOD Reset Flag
</b><br>
The BOD reset flag is set by the Reset Signal from the Brown-Out Detector to indicate the previous reset source.
<br>
0 = No reset from BOD.
<br>
1 = The BOD had issued the reset signal to reset the system.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[5]</td><td>SYSRF</td><td><div style="word-wrap: break-word;"><b>System Reset Flag
</b><br>
The system reset flag is set by the Reset Signal from the Cortex-M0 Core to indicate the previous reset source.
<br>
0 = No reset from Cortex-M0.
<br>
1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 core.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[7]</td><td>CPURF</td><td><div style="word-wrap: break-word;"><b>CPU Reset Flag
</b><br>
The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).
<br>
0 = No reset from CPU.
<br>
1 = The Cortex-M0 Core and FMC are reset by software setting CPURST to 1.
<br>
Note: Write 1 to clear this bit to 0.
<br>
</div></td></tr><tr><td>
[8]</td><td>LOCKRF</td><td><div style="word-wrap: break-word;"><b>Lockup Reset Flag
</b><br>
0 = No reset from Cortex-M0.
<br>
1 = The Cortex-M0 had issued the reset signal to reset the system by Cortex-M0 lockup event.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03170">3170</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ada3e3ddeb8141931780427b8358dc109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3e3ddeb8141931780427b8358dc109">&#9670;&nbsp;</a></span>TEMPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::TEMPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0020] Temperature Sensor Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TEMPCTL
</font><br><p> <font size="2">
Offset: 0x20  Temperature Sensor Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>VTEMPEN</td><td><div style="word-wrap: break-word;"><b>Temperature Sensor Enable Bit
</b><br>
This bit is used to enable/disable temperature sensor function.
<br>
0 = Temperature sensor function Disabled (default).
<br>
1 = Temperature sensor function Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03180">3180</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a3720cebf4699c1cad907df1df656e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3720cebf4699c1cad907df1df656e717">&#9670;&nbsp;</a></span>WKSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYS_T::WKSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x007c] System Wakeup Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WKSTS
</font><br><p> <font size="2">
Offset: 0x7C  System Wakeup Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ACMPWK</td><td><div style="word-wrap: break-word;"><b>ACMP Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with ACMP wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[1]</td><td>I2C1WK</td><td><div style="word-wrap: break-word;"><b>I2C1 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with I2C1 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[2]</td><td>I2C0WK</td><td><div style="word-wrap: break-word;"><b>I2C0 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with I2C0 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR3WK</td><td><div style="word-wrap: break-word;"><b>TMR3 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested withTMR3 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR2WK</td><td><div style="word-wrap: break-word;"><b>TMR2 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested withTMR2 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR1WK</td><td><div style="word-wrap: break-word;"><b>TMR1 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested withTMR1 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[6]</td><td>TMR0WK</td><td><div style="word-wrap: break-word;"><b>TMR0 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested withTMR0 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[7]</td><td>WDTWK</td><td><div style="word-wrap: break-word;"><b>WDT Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with WDT wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[8]</td><td>BODWK</td><td><div style="word-wrap: break-word;"><b>BOD Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with BOD wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[9]</td><td>SPI3WK</td><td><div style="word-wrap: break-word;"><b>SPI3 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with SPI3 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[10]</td><td>SPI2WK</td><td><div style="word-wrap: break-word;"><b>SPI2 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with SPI2 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[11]</td><td>SPI1WK</td><td><div style="word-wrap: break-word;"><b>SPI1 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with SPI1 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[12]</td><td>SPI0WK</td><td><div style="word-wrap: break-word;"><b>SPI0 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with SPI0 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[13]</td><td>UART1WK</td><td><div style="word-wrap: break-word;"><b>UART1 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with UART1 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[14]</td><td>UART0WK</td><td><div style="word-wrap: break-word;"><b>UART0 Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with UART0 wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[15]</td><td>RTCWK</td><td><div style="word-wrap: break-word;"><b>RTC Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with a RTC alarm or tick time happened
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr><tr><td>
[16]</td><td>GPIOWK</td><td><div style="word-wrap: break-word;"><b>GPIO Wake-up Flag (Read Only)
</b><br>
This flag indicates that wakeup of device from Power-down mode was requested with GPIO wakeup event
<br>
This flag is cleared when Power-down mode is entered.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l03215">3215</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano103bsp/Library/Device/Nuvoton/Nano103/Include/<a class="el" href="_nano103_8h_source.html">Nano103.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 7 2019 13:29:37 for Nano103 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
