<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano103 BSP: UART_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano103 BSP
   &#160;<span id="projectnumber">V3.01.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano103 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">UART_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano103_8h_source.html">Nano103.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a02b6f92555f0223a7cf1b7f28d62a63f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a02b6f92555f0223a7cf1b7f28d62a63f">DAT</a></td></tr>
<tr class="separator:a02b6f92555f0223a7cf1b7f28d62a63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e93f197d9ca7147675afba211e2f66"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ac2e93f197d9ca7147675afba211e2f66">CTRL</a></td></tr>
<tr class="separator:ac2e93f197d9ca7147675afba211e2f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabb58cc2e95cfafa6b62518953d37aa"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#afabb58cc2e95cfafa6b62518953d37aa">LINE</a></td></tr>
<tr class="separator:afabb58cc2e95cfafa6b62518953d37aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf055aeb3159102df9c35e5fc62359c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a0cf055aeb3159102df9c35e5fc62359c">INTEN</a></td></tr>
<tr class="separator:a0cf055aeb3159102df9c35e5fc62359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada15f66e56e66795932cb68174048260"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ada15f66e56e66795932cb68174048260">INTSTS</a></td></tr>
<tr class="separator:ada15f66e56e66795932cb68174048260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385bb54fc0aa8cfedbb3a51aabbd201"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a0385bb54fc0aa8cfedbb3a51aabbd201">TRSR</a></td></tr>
<tr class="separator:a0385bb54fc0aa8cfedbb3a51aabbd201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e343a39888f896bb89cb13a6cd56e6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a13e343a39888f896bb89cb13a6cd56e6">FIFOSTS</a></td></tr>
<tr class="separator:a13e343a39888f896bb89cb13a6cd56e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38873ff3f8930d902c756500ec1eb4a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#aa38873ff3f8930d902c756500ec1eb4a">MODEM</a></td></tr>
<tr class="separator:aa38873ff3f8930d902c756500ec1eb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccaf08eb25ede5ba592d720ef865d93"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#abccaf08eb25ede5ba592d720ef865d93">TOUT</a></td></tr>
<tr class="separator:abccaf08eb25ede5ba592d720ef865d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60210f63317de5a3432d775dbc4c9209"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a60210f63317de5a3432d775dbc4c9209">BAUD</a></td></tr>
<tr class="separator:a60210f63317de5a3432d775dbc4c9209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01ae1a9bbaa02f54a6e7cc944450b62"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ac01ae1a9bbaa02f54a6e7cc944450b62">IRDA</a></td></tr>
<tr class="separator:ac01ae1a9bbaa02f54a6e7cc944450b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c7acfa6d3c8de8524c72fc78d76f1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a252c7acfa6d3c8de8524c72fc78d76f1">ALTCTL</a></td></tr>
<tr class="separator:a252c7acfa6d3c8de8524c72fc78d76f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1259d698217673bdf587e52f022961"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a5f1259d698217673bdf587e52f022961">FUNCSEL</a></td></tr>
<tr class="separator:a5f1259d698217673bdf587e52f022961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addee961c3642852f960bb426edc59515"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#addee961c3642852f960bb426edc59515">BRCOMPAT</a></td></tr>
<tr class="separator:addee961c3642852f960bb426edc59515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a08d918703ebf59b9411bb75630d571"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#a7a08d918703ebf59b9411bb75630d571">WKUPEN</a></td></tr>
<tr class="separator:a7a08d918703ebf59b9411bb75630d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dde4f2d0c4c58d5042a48da1dff0e6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___t.html#ac9dde4f2d0c4c58d5042a48da1dff0e6">WKUPSTS</a></td></tr>
<tr class="separator:ac9dde4f2d0c4c58d5042a48da1dff0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
Memory Mapped Structure for UART Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l18880">18880</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a252c7acfa6d3c8de8524c72fc78d76f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c7acfa6d3c8de8524c72fc78d76f1">&#9670;&nbsp;</a></span>ALTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0034] UART Alternate Control State Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ALTCTL
</font><br><p> <font size="2">
Offset: 0x34  UART Alternate Control State Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[2:0]</td><td>BRKFL</td><td><div style="word-wrap: break-word;"><b>LIN TX Break Field Count
</b><br>
The field contains 3-bit LIN TX break field count.
<br>
Note: The break field length is BRKFL + 8.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>LINHSEL</td><td><div style="word-wrap: break-word;"><b>LIN Header Selection
</b><br>
00 = The LIN header includes break field.
<br>
01 = The LIN header includes break field + sync field.
<br>
10 = The LIN header includes break field + sync field + PID field.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[6]</td><td>LINRXEN</td><td><div style="word-wrap: break-word;"><b>LIN RX Enable Control
</b><br>
When LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (LININT)
<br>
0 = LIN RX mode Disabled.
<br>
1 = LIN RX mode Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>LINTXEN</td><td><div style="word-wrap: break-word;"><b>LIN TX Header Trigger Enable Bit
</b><br>
The LIN TX header can be break field or break and sync field or break, sync and frame ID field, it is depend on setting LINHSEL (UART_ALT_CSR[5:4]).
<br>
0 = Send LIN TX header Disabled.
<br>
1 = Send LIN TX header Enabled.
<br>
Note1: This bit will be cleared automatically and generate a interrupt to CPU (LININT).
<br>
Note2: When transmitter header field (it may be break or break + sync or break + sync + frame ID selected by LINHSEL (UART_ALT_CSR[5:4]) field) transfer operation finished, this bit will be cleared automatically.
<br>
Note3: If user wants to receive transmit data, it recommended to enable LINRXEN bit.
<br>
</div></td></tr><tr><td>
[8]</td><td>BITERREN</td><td><div style="word-wrap: break-word;"><b>Bit Error Detect Enable Bit
</b><br>
0 = Bit error detection Disabled.
<br>
1 = Bit error detection Enabled.
<br>
Note: In LIN function mode, when bit error occurs, the BITEF (UART_TRSR[5]) flag will be asserted
<br>
If the LINIEN (UART_IER[8]) = 1, an interrupt will be generated .
<br>
</div></td></tr><tr><td>
[16]</td><td>RS485NMM</td><td><div style="word-wrap: break-word;"><b>RS-485 Normal Multi-drop Operation Mode (NMM)
</b><br>
0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
<br>
1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
<br>
Note: It cannot be active with RS-485_AAD operation mode.
<br>
</div></td></tr><tr><td>
[17]</td><td>RS485AAD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Address Detection Operation Mode (AAD)
</b><br>
0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
<br>
1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
<br>
Note: It cannot be active with RS485NMM operation mode.
<br>
</div></td></tr><tr><td>
[18]</td><td>RS485AUD</td><td><div style="word-wrap: break-word;"><b>RS-485 Auto Direction Function (AUD)
</b><br>
0 = RS-485 Auto Direction Operation function (AUD) Disabled.
<br>
1 = RS-485 Auto Direction Operation function (AUD) Enabled.
<br>
Note: It can be active with RS485AAD or RS485NMM operation mode.
<br>
</div></td></tr><tr><td>
[19]</td><td>ADDRDEN</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Detection Enable Bit
</b><br>
This bit is used to enable RS-485 Address Detection mode.
<br>
0 = Address detection mode Disabled.
<br>
1 = Address detection mode Enabled.
<br>
Note: This bit is used for RS-485 any operation mode.
<br>
</div></td></tr><tr><td>
[31:24]</td><td>ADRMPID</td><td><div style="word-wrap: break-word;"><b>Address / PID Match Value Register
</b><br>
When in the RS-485 Function Mode, this field contains the RS-485 address match values.
<br>
When in the LIN Function mode, this field contains the LIN protected identifier field, software fills ID0~ID5 (PID [5:0]), hardware will calculate P0 and P1.
<br>
Note: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20117">20117</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a60210f63317de5a3432d775dbc4c9209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60210f63317de5a3432d775dbc4c9209">&#9670;&nbsp;</a></span>BAUD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::BAUD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0024] UART Baud Rate Divisor Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BAUD
</font><br><p> <font size="2">
Offset: 0x24  UART Baud Rate Divisor Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>BRD</td><td><div style="word-wrap: break-word;"><b>Baud Rate Divider
</b><br>
The field indicates the baud rate divider
<br>
This filed is used in baud rate calculation
<br>
The detail description is shown in UART Controller Baud Rate Generation.
<br>
</div></td></tr><tr><td>
[31]</td><td>DIV16EN</td><td><div style="word-wrap: break-word;"><b>Divider 16 Enable Control
</b><br>
The BRD = Baud Rate Divider, and the baud rate equation is  Baud Rate = UART_CLK/ [M * (BRD + 1)]; The default value of M is 16.
<br>
0 = The equation of baud rate is UART_CLK / [ (BRD+1)].
<br>
1 = The equation of baud rate is UART_CLK / [16 * (BRD+1)].
<br>
Note: In IrDA mode, this bit must clear to 0.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20112">20112</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="addee961c3642852f960bb426edc59515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addee961c3642852f960bb426edc59515">&#9670;&nbsp;</a></span>BRCOMPAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::BRCOMPAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x003c] UART Baud Rate Compensation Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BRCOMPAT
</font><br><p> <font size="2">
Offset: 0x3C  UART Baud Rate Compensation Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>BRCOMPAT</td><td><div style="word-wrap: break-word;"><b>Baud Rate Compensation Patten
</b><br>
These 9 bits are used to define the relative bit is compensated or not
<br>
BRCOMPAT[7:0] is used to define the compensation of D[7:0] and BRCOMPAT{[8] is used to define the parity bit.
<br>
</div></td></tr><tr><td>
[31]</td><td>BRCOMPDEC</td><td><div style="word-wrap: break-word;"><b>Baud Rate Compensation Decrease
</b><br>
0 = Positive (increase one module clock) compensation for each compensated bit.
<br>
1 = Negative (decrease one module clock) compensation for each compensated bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20119">20119</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ac2e93f197d9ca7147675afba211e2f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e93f197d9ca7147675afba211e2f66">&#9670;&nbsp;</a></span>CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::CTRL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0004] UART Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTRL
</font><br><p> <font size="2">
Offset: 0x04  UART Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXRST</td><td><div style="word-wrap: break-word;"><b>RX Field Software Reset
</b><br>
When RXRST (UART_CTL[0]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = Reset the RX internal state machine and pointers.
<br>
Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
<br>
</div></td></tr><tr><td>
[1]</td><td>TXRST</td><td><div style="word-wrap: break-word;"><b>TX Field Software Reset
</b><br>
When TXRST (UART_CTL[1]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
<br>
0 = No effect.
<br>
1 = Reset the TX internal state machine and pointers.
<br>
Note: This bit will automatically clear at least 3 UART peripheral clock cycles
<br>
</div></td></tr><tr><td>
[2]</td><td>RXOFF</td><td><div style="word-wrap: break-word;"><b>Receiver Disable Bit
</b><br>
0 = Receiver Enabled.
<br>
1 = Receiver Disabled.
<br>
Note1: In RS-485 NMM mode, user can set this bit to receive data before detecting address byte.
<br>
Note2: In RS-485 AAD mode, this bit will be setting to 1 automatically.
<br>
Note3: In RS-485 AUD mode and LIN break + sync +PID header mode, hardware will control data automatically, so don't fill any value to this bit.
<br>
</div></td></tr><tr><td>
[3]</td><td>TXOFF</td><td><div style="word-wrap: break-word;"><b>Transfer Disable Bit
</b><br>
0 = Transfer Enabled.
<br>
1 = Transfer Disabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>ATORTSEN</td><td><div style="word-wrap: break-word;"><b>nRTS Auto-flow Control Enable Bit
</b><br>
0 = nRTS auto-flow control Disabled.
<br>
1 = nRTS auto-flow control Enabled.
<br>
Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_TLCTL[13:12]), the UART will de-assert nRTS signal.
<br>
</div></td></tr><tr><td>
[5]</td><td>ATOCTSEN</td><td><div style="word-wrap: break-word;"><b>nCTS Auto-flow Control Enable Bit
</b><br>
0 = nCTS auto-flow control Disabled.
<br>
1 = nCTS auto-flow control Enabled.
<br>
Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
<br>
</div></td></tr><tr><td>
[6]</td><td>RXDMAEN</td><td><div style="word-wrap: break-word;"><b>RX DMA Enable Bit
</b><br>
This bit can enable or disable RX DMA service.
<br>
0 = RX DMA Disabled.
<br>
1 = RX DMA Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>TXDMAEN</td><td><div style="word-wrap: break-word;"><b>TX DMA Enable Bit
</b><br>
This bit can enable or disable TX DMA service.
<br>
0 = TX DMA Disabled.
<br>
1 = TX DMA Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>FTOEN</td><td><div style="word-wrap: break-word;"><b>Frame Time Out Enable Bit
</b><br>
This bit is used to enable the timer counter even the FIFO is still empty.
<br>
0 = Frame time out Disabled.
<br>
1 = Frame time out Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>ABRDEN</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Detect Enable Bit
</b><br>
0 = Auto-baud rate detect function Disabled.
<br>
1 = Auto-baud rate detect function Enabled.
<br>
Note: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (ABRIF) will be generated (If ABRIEN (UART_IER [7]) be enabled).
<br>
</div></td></tr><tr><td>
[14:13]</td><td>ABRDBITS</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Detect Bit Length
</b><br>
00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
<br>
01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
<br>
10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
<br>
11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
<br>
Note: The calculation of bit number includes the START bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20104">20104</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a02b6f92555f0223a7cf1b7f28d62a63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b6f92555f0223a7cf1b7f28d62a63f">&#9670;&nbsp;</a></span>DAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0000] UART Receive/Transmit Buffer Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DAT
</font><br><p> <font size="2">
Offset: 0x00  UART Receive/Transmit Buffer Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DAT</td><td><div style="word-wrap: break-word;"><b>Receive /Transmit Buffer
</b><br>
Write Operation:
<br>
By writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the UART_DAT.
<br>
Read Operation:
<br>
By reading this register, the UART will return an 8-bit data received from receiving FIFO.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20103">20103</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a13e343a39888f896bb89cb13a6cd56e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e343a39888f896bb89cb13a6cd56e6">&#9670;&nbsp;</a></span>FIFOSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FIFOSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0018] UART FIFO Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FIFOSTS
</font><br><p> <font size="2">
Offset: 0x18  UART FIFO Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXOVIF</td><td><div style="word-wrap: break-word;"><b>RX Overflow Error Status Flag (Read Only)
</b><br>
This bit is set when RX FIFO overflow
<br>
If the number of bytes of received data is greater than RX_FIFO (UART_RBR) size, this bit will be set.
<br>
0 = RX FIFO is not overflow.
<br>
1 = RX FIFO is overflow.
<br>
Note: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXEMPTY</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Empty (Read Only)
</b><br>
This bit initiate RX FIFO empty or not.
<br>
0 = RX FIFO is not empty.
<br>
1 = RX FIFO is empty.
<br>
Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high
<br>
It will be cleared when UART receives any new data.
<br>
</div></td></tr><tr><td>
[2]</td><td>RXFULL</td><td><div style="word-wrap: break-word;"><b>Receiver FIFO Full (Read Only)
</b><br>
This bit initiates RX FIFO full or not.
<br>
0 = RX FIFO is not full.
<br>
1 = RX FIFO is full.
<br>
Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[4]</td><td>PEF</td><td><div style="word-wrap: break-word;"><b>Parity Error State Status Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid parity bit.
<br>
0 = No parity error is generated.
<br>
1 = Parity error is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>FEF</td><td><div style="word-wrap: break-word;"><b>Framing Error Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
<br>
0 = No framing error is generated.
<br>
1 = Framing error is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[6]</td><td>BIF</td><td><div style="word-wrap: break-word;"><b>Break Interrupt Flag( Read Only)
</b><br>
This bit is set to logic 1 whenever the received data input (RX) is held in the spacing state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
<br>
0 = No Break interrupt is generated.
<br>
1 = Break interrupt is generated.
<br>
Note: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[8]</td><td>TXOVIF</td><td><div style="word-wrap: break-word;"><b>TX Overflow Error Interrupt Status Flag (Read Only)
</b><br>
If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
<br>
0 = TX FIFO did not overflow.
<br>
1 = TX FIFO overflowed.
<br>
Note: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>TXEMPTY</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Empty (Read Only)
</b><br>
This bit indicates TX FIFO empty or not.
<br>
0 = TX FIFO is not empty.
<br>
1 = TX FIFO is empty.
<br>
Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high
<br>
It will be cleared when writing data into DAT (TX FIFO not empty).
<br>
</div></td></tr><tr><td>
[10]</td><td>TXFULL</td><td><div style="word-wrap: break-word;"><b>Transmitter FIFO Full (Read Only)
</b><br>
This bit indicates TX FIFO full or not.
<br>
0 = TX FIFO is not full.
<br>
1 = TX FIFO is full.
<br>
Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[11]</td><td>TXENDF</td><td><div style="word-wrap: break-word;"><b>Transmitter Empty Flag (Read Only)
</b><br>
This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
<br>
0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
<br>
1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
<br>
Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
<br>
</div></td></tr><tr><td>
[20:16]</td><td>RXPTR</td><td><div style="word-wrap: break-word;"><b>RX FIFO Pointer (Read Only)
</b><br>
This field indicates the RX FIFO Buffer Pointer
<br>
When UART receives one byte from external device, RXPTR increases one
<br>
When one byte of RX FIFO is read by CPU, RXPTR decreases one.
<br>
The Maximum value shown in RXPTR is 15
<br>
When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0
<br>
As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15
<br>
</div></td></tr><tr><td>
[28:24]</td><td>TXPTR</td><td><div style="word-wrap: break-word;"><b>TX-fIFO Pointer (Read Only)
</b><br>
This field indicates the TX FIFO Buffer Pointer
<br>
When CPU writes one byte into UART_DAT, TXPTR increases one
<br>
When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
<br>
The Maximum value shown in TXPTR is 15
<br>
When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0
<br>
As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20109">20109</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a5f1259d698217673bdf587e52f022961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1259d698217673bdf587e52f022961">&#9670;&nbsp;</a></span>FUNCSEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::FUNCSEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0038] UART Function Select Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FUNCSEL
</font><br><p> <font size="2">
Offset: 0x38  UART Function Select Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>FUNCSEL</td><td><div style="word-wrap: break-word;"><b>Function Selection
</b><br>
00 = UART function mode.
<br>
01 = LIN function mode.
<br>
10 = IrDA function mode.
<br>
11 = RS-485 function mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20118">20118</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a0cf055aeb3159102df9c35e5fc62359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf055aeb3159102df9c35e5fc62359c">&#9670;&nbsp;</a></span>INTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x000c] UART Interrupt Enable Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN
</font><br><p> <font size="2">
Offset: 0x0C  UART Interrupt Enable Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIEN</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Enable Bit
</b><br>
0 = Receive data available interrupt Disabled.
<br>
1 = Receive data available interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>THREIEN</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Enable Bit
</b><br>
0 = Transmit holding register empty interrupt Disabled.
<br>
1 = Transmit holding register empty interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>RLSIEN</td><td><div style="word-wrap: break-word;"><b>Receive Line Status Interrupt Enable Bit
</b><br>
0 = Receive Line Status interrupt Disabled.
<br>
1 = Receive Line Status interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEMIEN</td><td><div style="word-wrap: break-word;"><b>Modem Status Interrupt Enable Bit
</b><br>
0 = Modem status interrupt Disabled.
<br>
1 = Modem status interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>RXTOIEN</td><td><div style="word-wrap: break-word;"><b>RX Time-out Interrupt Enable Bit
</b><br>
0 = RX time-out interrupt Disabled.
<br>
1 = RX time-out interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>BUFERRIEN</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Enable Bit
</b><br>
0 = Buffer error interrupt Disabled.
<br>
1 = Buffer error interrupt Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>WKUPIEN</td><td><div style="word-wrap: break-word;"><b>Wake-up Interrupt Enable Bit
</b><br>
0 = Wake-up system function Disabled.
<br>
1 = Wake-up system function Enabled, when the system is in Power-down mode, one of the wake-up event will wake-up system from Power-down mode.
<br>
Note: Hardware will clear one of the wake-up status bits in UART_WKUPSTS when the wake-up operation finishes and system clock work stable
<br>
</div></td></tr><tr><td>
[7]</td><td>ABRIEN</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Interrupt Enable Bit
</b><br>
0 = Auto-baud rate interrupt Disabled.
<br>
1 = Auto-baud rate interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>LINIEN</td><td><div style="word-wrap: break-word;"><b>LIN Bus Interrupt Enable Bit
</b><br>
0 = LIN bus interrupt Disabled.
<br>
1 = LIN bus interrupt Enabled.
<br>
Note: This bit is used for LIN function mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>TXENDIEN</td><td><div style="word-wrap: break-word;"><b>Transmitter Empty Interrupt Enable Bit
</b><br>
0 = Transmit Empty interrupt Disabled.
<br>
1 = Transmit Empty interrupt Enabled.
<br>
Note: If the bit is enabled, there is interrupt event when the TXENDF (UART_FSR[11]) is activated.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20106">20106</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ada15f66e56e66795932cb68174048260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada15f66e56e66795932cb68174048260">&#9670;&nbsp;</a></span>INTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0010] UART Interrupt Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS
</font><br><p> <font size="2">
Offset: 0x10  UART Interrupt Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIF</td><td><div style="word-wrap: break-word;"><b>Receive Data Available Interrupt Flag (Read Only)
</b><br>
When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_ISR[0]) will be set
<br>
If RDAIEN (UART_IER [0]) is enabled, the RDA interrupt will be generated.
<br>
0 = No RDA interrupt flag is generated.
<br>
1 = RDA interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_TLCTL[9:8])
<br>
</div></td></tr><tr><td>
[1]</td><td>THREIF</td><td><div style="word-wrap: break-word;"><b>Transmit Holding Register Empty Interrupt Flag (Read Only)
</b><br>
This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register
<br>
If THREIEN (UART_IER[1]) is enabled, the THRE interrupt will be generated.
<br>
0 = No THRE interrupt flag is generated.
<br>
1 = THRE interrupt flag is generated.
<br>
Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty)
<br>
</div></td></tr><tr><td>
[2]</td><td>RLSIF</td><td><div style="word-wrap: break-word;"><b>Receive Line Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FSR[6]), FEF(UART_FSR[5]) and PEF(UART_FSR[4]), is set)
<br>
If RLSIEN (UART_IER [2]) is enabled, the RLS interrupt will be generated.
<br>
0 = No RLS interrupt flag is generated.
<br>
1 = RLS interrupt flag is generated.
<br>
Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit"
<br>
At the same time, the bit of ADDRDETF (UART_TRSR[0]) is also set.
<br>
Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FSR[6]), FEF(UART_FSR[5]) and PEF(UART_FSR[4]) are cleared.
<br>
Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FSR[6]) , FEF(UART_FSR[5]) and PEF(UART_FSR[4]) and ADDRDETF (UART_TRSR[0]) are cleared.
<br>
</div></td></tr><tr><td>
[3]</td><td>MODEMIF</td><td><div style="word-wrap: break-word;"><b>MODEM Interrupt Flag (Read Only) Channel
</b><br>
This bit is set when the nCTS pin has state change (CTSDETF (UART_MCSR[18]) = 1)
<br>
If MODEMIEN (UART_IER [3]) is enabled, the Modem interrupt will be generated.
<br>
0 = No Modem interrupt flag is generated.
<br>
1 = Modem interrupt flag is generated.
<br>
Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MCSR[18]).
<br>
</div></td></tr><tr><td>
[4]</td><td>RXTOIF</td><td><div style="word-wrap: break-word;"><b>Rime-out Interrupt Flag (Read Only)
</b><br>
This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC
<br>
If RXTOIEN (UART_IER [4]) is enabled, the Tout interrupt will be generated.
<br>
0 = No Time-out interrupt flag is generated.
<br>
1 = Time-out interrupt flag is generated.
<br>
Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it
<br>
</div></td></tr><tr><td>
[5]</td><td>BUFERRIF</td><td><div style="word-wrap: break-word;"><b>Buffer Error Interrupt Flag (Read Only)
</b><br>
This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FSR[8]) or RXOVIF (UART_FSR[0]) is set)
<br>
When BUFERRIF (UART_ISR[5])is set, the transfer is not correct
<br>
If BFERRIEN (UART_IER [5]) is enabled, the buffer error interrupt will be generated.
<br>
0 = No buffer error interrupt flag is generated.
<br>
1 = Buffer error interrupt flag is generated.
<br>
Note: This bit is read only
<br>
This bit is cleared if both of RXOVIF(UART_FSR[0]) and TXOVIF(UART_FSR[8]) are cleared to 0 by writing 1 to RXOVIF(UART_FSR[0]) and TXOVIF(UART_FSR[8]).
<br>
</div></td></tr><tr><td>
[6]</td><td>WKUPIF</td><td><div style="word-wrap: break-word;"><b>Wake-up Interrupt Flag (Read Only)
</b><br>
This bit is set if chip wake-up from power-down state by one of UART controller wake-up event.
<br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by one of UART controller wake-up event.
<br>
Note1: If WKDATEN (UART_IER[6]) is enabled, the wake-up interrupt is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to one of UART_WKUPSTS[4:0] (THRTOWKSTS or THRWKSTS or CTSWKSTS or DATWKSTS or ADRWKSTS).
<br>
</div></td></tr><tr><td>
[7]</td><td>ABRIF</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Interrupt Status Flag (Read Only)
</b><br>
This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN (UART_IER[7]) is set then the auto-baud rate interrupt will be generated.
<br>
0 = No Auto-Baud Rate interrupt is generated.
<br>
1 = Auto-Baud Rate interrupt is generated.
<br>
Note1: This bit is read only, but can be cleared by writing 1 to ABRDTOIF (UART_TRSR[2]) or ABRDIF (UART_TRSR[1]).
<br>
Note2: This bit is cleared when both the ABRDTOIF and ABRDIF are cleared.
<br>
</div></td></tr><tr><td>
[8]</td><td>LINIF</td><td><div style="word-wrap: break-word;"><b>LIN Interrupt Status Flag (Read Only)
</b><br>
This bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LINIEN(UART_IER[8]) is set then the LIN interrupt will be generated.
<br>
0 = No LIN interrupt is generated.
<br>
1 = LIN interrupt is generated.
<br>
Note1: This bit is read only, but can be cleared by it by writing 1 to BITEF (UART_TRSR[5]), LINTXIF (UART_TRSR[3]) or LINRXIF (UART_TRSR[4]).
<br>
Note2: This bit is cleared when both the BITEF, LINTXIF and LINRXIF are cleared.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20107">20107</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ac01ae1a9bbaa02f54a6e7cc944450b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01ae1a9bbaa02f54a6e7cc944450b62">&#9670;&nbsp;</a></span>IRDA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::IRDA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0030] UART IrDA Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IRDA
</font><br><p> <font size="2">
Offset: 0x30  UART IrDA Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>TXEN</td><td><div style="word-wrap: break-word;"><b>IrDA Receiver/Transmitter Selection Enable Bit
</b><br>
0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
<br>
1 = IrDA Transmitter Enabled and Receiver Disabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>TXINV</td><td><div style="word-wrap: break-word;"><b>IrDA Inverse Transmitting Output Signal
</b><br>
0 = None inverse transmitting signal. (Default)
<br>
1 = Inverse transmitting output signal.
<br>
</div></td></tr><tr><td>
[6]</td><td>RXINV</td><td><div style="word-wrap: break-word;"><b>IrDA Inverse Receive Input Signal
</b><br>
0 = None inverse receiving input signal.
<br>
1 = Inverse receiving input signal. (Default)
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20116">20116</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="afabb58cc2e95cfafa6b62518953d37aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabb58cc2e95cfafa6b62518953d37aa">&#9670;&nbsp;</a></span>LINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::LINE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0008] UART Transfer Line Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LINE
</font><br><p> <font size="2">
Offset: 0x08  UART Transfer Line Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>WLS</td><td><div style="word-wrap: break-word;"><b>Word Length Selection
</b><br>
This field sets UART word length.
<br>
00 = 5 bits.
<br>
01 = 6 bits.
<br>
10 = 7 bits.
<br>
11 = 8 bits.
<br>
</div></td></tr><tr><td>
[2]</td><td>NSB</td><td><div style="word-wrap: break-word;"><b>Number of STOP Bit
</b><br>
0 = One STOP bit is generated in the transmitted data.
<br>
1 = When select 5-bit word length, 1.5 STOP bit is generated in the transmitted data
<br>
When select 6-, 7- and 8-bit word length, 2 STOP bit is generated in the transmitted data.
<br>
</div></td></tr><tr><td>
[3]</td><td>PBE</td><td><div style="word-wrap: break-word;"><b>Parity Bit Enable Bit
</b><br>
0 = No parity bit generated Disabled.
<br>
1 = Parity bit generated Enabled.
<br>
Note: Parity bit is generated on each outgoing character and is checked on each incoming data.
<br>
</div></td></tr><tr><td>
[4]</td><td>EPE</td><td><div style="word-wrap: break-word;"><b>Even Parity Enable Bit
</b><br>
0 = Odd number of logic 1's is transmitted and checked in each word.
<br>
1 = Even number of logic 1's is transmitted and checked in each word.
<br>
Note: This bit has effect only when PBE (UART_TLCTL[3]) is set.
<br>
</div></td></tr><tr><td>
[5]</td><td>SPE</td><td><div style="word-wrap: break-word;"><b>Stick Parity Enable Bit
</b><br>
0 = Stick parity Disabled.
<br>
1 = Stick parity Enabled.
<br>
Note: If PBE (UART_TLCTL[3]) and EPE (UART_TLCTL[4]) are logic 1, the parity bit is transmitted and checked as logic 0
<br>
If PBE (UART_TLCTL[3]) is 1 and EPE (UART_TLCTL[4]) is 0 then the parity bit is transmitted and checked as 1.
<br>
</div></td></tr><tr><td>
[6]</td><td>BCB</td><td><div style="word-wrap: break-word;"><b>Break Control Bit
</b><br>
0 = Break Control Disabled.
<br>
1 = Break Control Enabled.
<br>
Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0)
<br>
This bit acts only on TX line and has no effect on the transmitter logic.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>RFITL</td><td><div style="word-wrap: break-word;"><b>RX FIFO Interrupt Trigger Level
</b><br>
When the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_IER [0]) enabled, and an interrupt will be generated).
<br>
0000 = RX FIFO Interrupt Trigger Level is 1 byte.
<br>
0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
<br>
0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
<br>
0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
<br>
Note: When operating in IrDA mode or RS-485 mode, the RFITL must be set to 0.
<br>
</div></td></tr><tr><td>
[13:12]</td><td>RTSTRGLV</td><td><div style="word-wrap: break-word;"><b>nRTS Trigger Level for Auto-flow Control Use
</b><br>
00 = nRTS Trigger Level is 1 byte.
<br>
01 = nRTS Trigger Level is 4 bytes.
<br>
10 = nRTS Trigger Level is 8 bytes.
<br>
11 = nRTS Trigger Level is 14 bytes.
<br>
Note: This field is used for auto nRTS flow control.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20105">20105</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aa38873ff3f8930d902c756500ec1eb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38873ff3f8930d902c756500ec1eb4a">&#9670;&nbsp;</a></span>MODEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::MODEM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x001c] UART Modem Control Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MODEM
</font><br><p> <font size="2">
Offset: 0x1C  UART Modem Control Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RTSACTLV</td><td><div style="word-wrap: break-word;"><b>nRTS Pin Active Level
</b><br>
This bit defines the active level state of nRTS pin output.
<br>
0 =n RTS pin output is high level active.
<br>
1 = nRTS pin output is low level active. (Default)
<br>
</div></td></tr><tr><td>
[1]</td><td>RTSSTS</td><td><div style="word-wrap: break-word;"><b>nRTS Pin State (Read Only)
</b><br>
This bit mirror from nRTS pin output of voltage logic status.
<br>
0 = nRTS pin output is low level voltage logic state.
<br>
1 = nRTS pin output is high level voltage logic state.
<br>
</div></td></tr><tr><td>
[16]</td><td>CTSACTLV</td><td><div style="word-wrap: break-word;"><b>nCTS Trigger Level
</b><br>
This bit defines the active level state of nCTS pin input.
<br>
0 = nCTS pin input is high level active.
<br>
1 = nCTS pin input is low level active. (Default)
<br>
</div></td></tr><tr><td>
[17]</td><td>CTSSTS</td><td><div style="word-wrap: break-word;"><b>nCTS Pin Status (Read Only)
</b><br>
This bit mirror from nCTS pin input of voltage logic status.
<br>
0 = nCTS pin input is low level voltage logic state.
<br>
1 = nCTS pin input is high level voltage logic state.
<br>
Note: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.
<br>
</div></td></tr><tr><td>
[18]</td><td>CTSDETF</td><td><div style="word-wrap: break-word;"><b>Detect nCTS State Change Flag (Read Only)
</b><br>
This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_IER[3]).
<br>
0 = nCTS input has not change state.
<br>
1 = nCTS input has change state.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20110">20110</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="abccaf08eb25ede5ba592d720ef865d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccaf08eb25ede5ba592d720ef865d93">&#9670;&nbsp;</a></span>TOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::TOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0020] UART Time-Out Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TOUT
</font><br><p> <font size="2">
Offset: 0x20  UART Time-Out Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>TOIC</td><td><div style="word-wrap: break-word;"><b>Time-out Comparator
</b><br>
The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word
<br>
Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TMCTL[8:0])), a receiver time-out interrupt (RXTOIF(UART_ISR[4])) is generated if RXTOIEN (UART_IER [4]) enabled
<br>
A new incoming data word or RX FIFO empty will clear RXTOIF(UART_ISR[4])
<br>
In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255
<br>
So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
<br>
Note1: Fill all 0 to this field indicates to disable this function.
<br>
Note2: The real time-out value is TOIC + 1.
<br>
Note3: The counting clock is baud rate clock.
<br>
Note4: The UART data format is start bit + 8 data bits + parity bit + stop bit, although software can configure this field by any value but it is recommend to fill this field great than 0xA.
<br>
</div></td></tr><tr><td>
[23:16]</td><td>DLY</td><td><div style="word-wrap: break-word;"><b>TX Delay Time Value
</b><br>
This field is used to programming the transfer delay time between the last stop bit and next start bit
<br>
The unit is bit time.
<br>
Note1: Fill all 0 to this field indicates to disable this function.
<br>
Note2: The real delay value is DLY.
<br>
Note3: The counting clock is baud rate clock.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20111">20111</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a0385bb54fc0aa8cfedbb3a51aabbd201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385bb54fc0aa8cfedbb3a51aabbd201">&#9670;&nbsp;</a></span>TRSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::TRSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0014] UART Transfer Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TRSR
</font><br><p> <font size="2">
Offset: 0x14  UART Transfer Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ADDRDETF</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Byte Detection Status Flag (Read Only)
</b><br>
0 = Receiver detects a data that is not an address bit (bit 9 ='0').
<br>
1 = Receiver detects a data that is an address bit (bit 9 ='1').
<br>
Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALT_CSR[19]) is set to 1 to enable Address detection mode .
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>ABRDIF</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Interrupt (Read Only)
</b><br>
This bit is set to logic 1 when auto-baud rate detect function finished.
<br>
0 = No Auto- Baud Rate interrupt is generated.
<br>
1= Auto-Baud Rate interrupt is generated.
<br>
Note: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[2]</td><td>ABRDTOIF</td><td><div style="word-wrap: break-word;"><b>Auto-baud Rate Time-out Interrupt (Read Only)
</b><br>
0 = Auto-baud rate counter is underflow.
<br>
1 = Auto-baud rate counter is overflow.
<br>
Note1: This bit is set to logic 1 in Auto-baud Rate Detect mode and the baud rate counter is overflow.
<br>
Note2: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>LINTXIF</td><td><div style="word-wrap: break-word;"><b>LIN TX Interrupt Flag (Read Only)
</b><br>
This bit is set to logic 1 when LIN transmitted header field
<br>
The header may be break field or break field + sync field or break field + sync field + PID field, it can be choose by setting LINHSEL (UART_ALT_CSR[5:4]) register.
<br>
0 = No LIN Transmit interrupt is generated.
<br>
1 = LIN Transmit interrupt is generated.
<br>
Note: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>LINRXIF</td><td><div style="word-wrap: break-word;"><b>LIN RX Interrupt Flag (Read Only)
</b><br>
This bit is set to logic 1 when received LIN header field
<br>
The header may be break field or break field + sync field or break field + sync field + PID field, and it can be choose by setting LINHSEL (UART_ALT_CSR[5:4]) register.
<br>
0 = No LIN Rx interrupt is generated.
<br>
1 = LIN Rx interrupt is generated.
<br>
Note: This bit is read only, but can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>BITEF</td><td><div style="word-wrap: break-word;"><b>Bit Error Detect Status Flag (Read Only)
</b><br>
At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state is not equal to the output pin (SOUT) state, BITEF will be set.
<br>
When occur bit error, hardware will generate an interrupt to CPU (LININT).
<br>
0 = No Bit error interrupt is generated.
<br>
1 = Bit error interrupt is generated.
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2: This bit is only valid when enabling the bit error detection function (BITERREN (UART_ALT_CSR[8]) = 1).
<br>
</div></td></tr><tr><td>
[7]</td><td>RXBUSY</td><td><div style="word-wrap: break-word;"><b>Receive Busy Status (Read Only)
</b><br>
0 = The receiver machine stays in idle state.
<br>
1 = The receiver machine stays in no Idle state.
<br>
Note: The user can use this to check the busy status in receiver mode
<br>
If the user want to enter the power down, this bit shall be confirm in Idle state and there is 2 UART clock latency for receiver pin.
<br>
</div></td></tr><tr><td>
[8]</td><td>SLVSYNCF</td><td><div style="word-wrap: break-word;"><b>LIN RX SYNC Error Flag (Read Only)
</b><br>
This bit is set to logic 1 when LIN received incorrect SYNC field.
<br>
User can choose the header by setting LINHSEL (UART_ALT_CSR[5:4]) register.
<br>
0 = No LIN Rx sync error is generated.
<br>
1 = LIN Rx sync error is generated.
<br>
Note: This bit is read only, but can be cleared by writing 1 to LINRXIF.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20108">20108</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a7a08d918703ebf59b9411bb75630d571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a08d918703ebf59b9411bb75630d571">&#9670;&nbsp;</a></span>WKUPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::WKUPEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0040] UART Wake-up Enable Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WKUPEN
</font><br><p> <font size="2">
Offset: 0x40  UART Wake-up Enable Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>WKCTSEN</td><td><div style="word-wrap: break-word;"><b>nCTS Wake-up Enable Bit
</b><br>
When the system is in power-down mode, an external nCTS change will wake-up system from power-down mode.
<br>
0 = nCTS wake-up function Disabled.
<br>
1 = nCTS wake-up function Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>WKDATEN</td><td><div style="word-wrap: break-word;"><b>Incoming Data Wake-up Enable Bit
</b><br>
0 = Incoming data wake-up function Disabled.
<br>
1 = Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode.
<br>
Note: Hardware will clear this bit when the incoming data wake-up operation finishes and system clock work stable
<br>
</div></td></tr><tr><td>
[2]</td><td>WKTHREN</td><td><div style="word-wrap: break-word;"><b>FIFO Threshold Reach Wake-up Enable Bit
</b><br>
0 = Received FIFO threshold reach wake-up function Disabled.
<br>
1 = Received FIFO threshold reach wake-up function Enabled when the system is in power-down mode.
<br>
Note: It is suggest the function is enabled in UART mode and the UART clock is selected in 32K.
<br>
</div></td></tr><tr><td>
[3]</td><td>WKTHRTOEN</td><td><div style="word-wrap: break-word;"><b>FIFO Threshold Reach Time Out Wake-up Enable Bit
</b><br>
0 = Received FIFO threshold no reach and time out wake-up function Disabled.
<br>
1 = Received FIFO threshold no reach and time out wake-up function Enabled when the system is in power-down mode.
<br>
Note: It is suggest the function is enabled when the WKTHREN (UART_WKUPEN[2]) is set to 1.
<br>
</div></td></tr><tr><td>
[4]</td><td>WKADRMEN</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Match Wake-up Enable Bit
</b><br>
0 = RS-485 ADD mode address match wake-up function Disabled.
<br>
1 = RS-485 AAD mode address match wake-up function Enabled when the system is in power-down mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20120">20120</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ac9dde4f2d0c4c58d5042a48da1dff0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dde4f2d0c4c58d5042a48da1dff0e6">&#9670;&nbsp;</a></span>WKUPSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_T::WKUPSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0044] UART Wake-up Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WKUPSTS
</font><br><p> <font size="2">
Offset: 0x44  UART Wake-up Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CTSWKSTS</td><td><div style="word-wrap: break-word;"><b>nCTS Wake-up Flag (Read Only)
</b><br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by nCTS wake-up.
<br>
Note1: If WKCTSEN (UART_ WKUPEN [0])is enabled, the wake-up function is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>DATWKSTS</td><td><div style="word-wrap: break-word;"><b>Data Wake-up Flag (Read Only)
</b><br>
This bit is set if chip wake-up from power-down state by data wake-up.
<br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by data wake-up.
<br>
Note1: If WKDATEN (UART_ WKUPEN [1]) is enabled, the wake-up function is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it
<br>
</div></td></tr><tr><td>
[2]</td><td>THRWKSTS</td><td><div style="word-wrap: break-word;"><b>Threshold Wake-up Flag (Read Only)
</b><br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by FIFO threshold wake-up.
<br>
Note1: If WKTHREN (UART_ WKUPEN [2])is enabled, the wake-up function is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>THRTOWKSTS</td><td><div style="word-wrap: break-word;"><b>Threshold Wake-up Time Out Flag (Read Only)
</b><br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by FIFO threshold time out wake-up.
<br>
Note1: If WKTHRTOEN (UART_ WKUPEN [3])is enabled, the wake-up function is generated.
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>ADRWKSTS</td><td><div style="word-wrap: break-word;"><b>RS-485 Address Byte Detection Wake-up Flag (Read Only)
</b><br>
0 = Chip stays in power-down state.
<br>
1 = Chip wake-up from power-down state by Receiver detects a data that is an address bit (bit 9 ='1').
<br>
Note1: If WKADRMEN (UART_WKUPEN[4])is enabled, the wake-up function is generated.
<br>
Note2: This field is used for RS-485 function mode and ADDRDEN (UART_ALT_CSR[19]) is set to 1 to enable Address detection mode .
<br>
Note2: This bit is read only, but can be cleared by writing '1' to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20121">20121</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano103bsp/Library/Device/Nuvoton/Nano103/Include/<a class="el" href="_nano103_8h_source.html">Nano103.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 19:35:34 for Nano103 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
