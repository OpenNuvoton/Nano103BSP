<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano103 BSP: SPI_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano103 BSP
   &#160;<span id="projectnumber">V3.01.001</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano103 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SPI_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano103_8h_source.html">Nano103.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a4af14c012bab1f4978af2ced01bb3ea7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4af14c012bab1f4978af2ced01bb3ea7">CTL</a></td></tr>
<tr class="separator:a4af14c012bab1f4978af2ced01bb3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a7dc0398240e38e1c356316e79a4d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a463a7dc0398240e38e1c356316e79a4d">STATUS</a></td></tr>
<tr class="separator:a463a7dc0398240e38e1c356316e79a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3de044e4b17cbd5af0001f256fe3f9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#aac3de044e4b17cbd5af0001f256fe3f9">CLKDIV</a></td></tr>
<tr class="separator:aac3de044e4b17cbd5af0001f256fe3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ced326eafea489fe145d80d96ac0cab"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a8ced326eafea489fe145d80d96ac0cab">SSCTL</a></td></tr>
<tr class="separator:a8ced326eafea489fe145d80d96ac0cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f90ba390534a31dbf6d59579bc58e8d"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a0f90ba390534a31dbf6d59579bc58e8d">RX0</a></td></tr>
<tr class="separator:a0f90ba390534a31dbf6d59579bc58e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a390675b7ba49bcf6c68083acc8742"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a65a390675b7ba49bcf6c68083acc8742">RX1</a></td></tr>
<tr class="separator:a65a390675b7ba49bcf6c68083acc8742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07b33f2435790396bd6b24fae145f71"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#af07b33f2435790396bd6b24fae145f71">TX0</a></td></tr>
<tr class="separator:af07b33f2435790396bd6b24fae145f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2956855bd2082e1cba653490856ba72f"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a2956855bd2082e1cba653490856ba72f">TX1</a></td></tr>
<tr class="separator:a2956855bd2082e1cba653490856ba72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70facf25a25f16b8d817cc8a5efee378"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a70facf25a25f16b8d817cc8a5efee378">PDMACTL</a></td></tr>
<tr class="separator:a70facf25a25f16b8d817cc8a5efee378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bd75cdeab853186f7fecead2e77f97"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a42bd75cdeab853186f7fecead2e77f97">FIFOCTL</a></td></tr>
<tr class="separator:a42bd75cdeab853186f7fecead2e77f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SPI Serial Peripheral Interface Controller(SPI)
Memory Mapped Structure for SPI Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l22569">22569</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="aac3de044e4b17cbd5af0001f256fe3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3de044e4b17cbd5af0001f256fe3f9">&#9670;&nbsp;</a></span>CLKDIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0008] SPI Clock Divider Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CLKDIV
</font><br><p> <font size="2">
Offset: 0x08  SPI Clock Divider Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DIVIDER</td><td><div style="word-wrap: break-word;"><b>Clock Divider
</b><br>
The value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_CLK
<br>
The desired frequency is obtained according to the following equation:
<br>
Where
<br>
is the SPI peripheral clock source
<br>
It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23395">23395</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a4af14c012bab1f4978af2ced01bb3ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af14c012bab1f4978af2ced01bb3ea7">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0000] SPI Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL
</font><br><p> <font size="2">
Offset: 0x00  SPI Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>GOBUSY</td><td><div style="word-wrap: break-word;"><b>SPI Transfer Control Bit and Busy Status
</b><br>
0 = Writing this bit 0 will stop data transfer if SPI is transferring.
<br>
1 = In Master mode, writing 1 to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the slave is ready to communicate with a master.
<br>
If the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'
<br>
As the transfer is finished, this bit will be cleared automatically
<br>
Software can read this bit to check if the SPI is in busy status.
<br>
In FIFO mode, this bit will be controlled by hardware
<br>
Software should not modify this bit
<br>
In slave mode, this bit always returns 1 when software reads this register
<br>
In master mode, this bit reflects the busy or idle status of SPI.
<br>
Note:
<br>
1.When FIFO mode is disabled, all configurations should be set before writing 1 to the GOBUSY bit in the SPI_CTL register.
<br>
2
<br>
When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXNEG</td><td><div style="word-wrap: break-word;"><b>Receive on Negative Edge
</b><br>
0 = The received data is latched on the rising edge of SPI_CLK.
<br>
1 = The received data is latched on the falling edge of SPI_CLK.
<br>
Note: Refer to Edge section.
<br>
</div></td></tr><tr><td>
[2]</td><td>TXNEG</td><td><div style="word-wrap: break-word;"><b>Transmit on Negative Edge
</b><br>
0 = The transmitted data output is changed on the rising edge of SPI_CLK.
<br>
1 = The transmitted data output is changed on the falling edge of SPI_CLK.
<br>
Note: Refer to Edge section.
<br>
</div></td></tr><tr><td>
[7:3]</td><td>DWIDTH</td><td><div style="word-wrap: break-word;"><b>Data Width
</b><br>
This field specifies how many bits can be transmitted / received in one transaction
<br>
The minimum bit length is 8 bits and can be up to 32 bits.
<br>
01000 = 8 bits are transmitted in one transaction.
<br>
01001 = 9 bits are transmitted in one transaction.
<br>
01010 = 10 bits are transmitted in one transaction.
<br>
-----
<br>
11111 = 31 bits are transmitted in one transaction.
<br>
00000 = 32 bits are transmitted in one transaction.
<br>
</div></td></tr><tr><td>
[10]</td><td>LSB</td><td><div style="word-wrap: break-word;"><b>Send LSB First
</b><br>
0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH (SPI_CTL[7:3]), is transmitted/received first.
<br>
1 = The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (SPI_RX0/1).
<br>
Note: Refer to LSB first section.
<br>
</div></td></tr><tr><td>
[11]</td><td>CLKPOL</td><td><div style="word-wrap: break-word;"><b>Clock Polarity
</b><br>
0 = The default level of SPI_CLK is low.
<br>
1 = The default level of SPI_CLK is high.
<br>
Note: Refer to Clock Parity section.
<br>
</div></td></tr><tr><td>
[15:12]</td><td>SUSPITV</td><td><div style="word-wrap: break-word;"><b>Suspend Interval (Master Only)
</b><br>
These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer
<br>
The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKPOL = 0
<br>
If CLKPOL = 1, the interval is from the rising clock edge to the falling clock edge.
<br>
The default value is 0x3
<br>
The desired suspend interval is obtained according to the following equation: )(SP_]YCLE[3]0) + 0.5) * period of SPI_CLK
<br>
For example,
<br>
SUSPITV = 0x0 .... 0.5 SPI_CLK clock cycle.
<br>
SUSPITV = 0x1 .... 1.5 SPI_CLK clock cycle.
<br>
......
<br>
SUSPITV = 0xE .... 14.5 SPI_CLK clock cycle.
<br>
SUSPITV = 0xF .... 15.5 SPI_CLK clock cycle.
<br>
</div></td></tr><tr><td>
[17]</td><td>UNITIEN</td><td><div style="word-wrap: break-word;"><b>Unit Transfer Interrupt Enable Bit
</b><br>
0 = SPI unit transfer interrupt Disabled.
<br>
1 = SPI unit transfer interrupt Enabled.
<br>
</div></td></tr><tr><td>
[18]</td><td>SLAVE</td><td><div style="word-wrap: break-word;"><b>Slave Mode Selection
</b><br>
0 = SPI controller set as Master mode.
<br>
1 = SPI controller set as Slave mode.
<br>
Note: Refer to Slave Selection section
<br>
</div></td></tr><tr><td>
[19]</td><td>REORDER</td><td><div style="word-wrap: break-word;"><b>Byte Reorder Function Enable Bit
</b><br>
0 = Byte reorder function Disabled.
<br>
1 = Enable byte reorder function and insert a byte suspend interval among each byte
<br>
The setting of DWIDTH must be configured as 00b ( 32 bits/ word)
<br>
Note: The suspend interval is defined in SUSPITV. Refer to Byte Reorder section.
<br>
Note: Byte Suspend is only used in SPI Byte Reorder mode.
<br>
</div></td></tr><tr><td>
[21]</td><td>FIFOM</td><td><div style="word-wrap: break-word;"><b>FIFO Mode Enable Bit
</b><br>
0 = FIFO mode Disabled (in Normal mode).
<br>
1 = FIFO mode Enabled.
<br>
Note: Refer to FIFO Mode section.
<br>
</div></td></tr><tr><td>
[22]</td><td>TWOBIT</td><td><div style="word-wrap: break-word;"><b>2-bit Transfer Mode Enable Bit
</b><br>
0 = 2-bit transfer mode Disabled.
<br>
1 = 2-bit transfer mode Enabled.
<br>
Refer to Two Bit Transfer Mode section
<br>
Note: automatically
<br>
</div></td></tr><tr><td>
[28]</td><td>DUALDIR</td><td><div style="word-wrap: break-word;"><b>Dual I/O Mode Direction Control
</b><br>
0 = Date read in the Dual I/O Mode function.
<br>
1 = Data write in the Dual I/O Mode function.
<br>
Refer to Dual I/O Mode section.
<br>
</div></td></tr><tr><td>
[29]</td><td>DUALIOEN</td><td><div style="word-wrap: break-word;"><b>Dual I/O Mode Enable Bit
</b><br>
0 = Dual I/O Mode function Disabled.
<br>
1 = Dual I/O Mode function Enabled.
<br>
Refer to Dual I/O Mode section.
<br>
</div></td></tr><tr><td>
[30]</td><td>WKSSEN</td><td><div style="word-wrap: break-word;"><b>Wake-up by Slave Select Enable Bit
</b><br>
0 = Wake-up function Disabled.
<br>
1 = Wake-up function Enabled.
<br>
Note: The Slave select wake-up function is only available in SPI Slave mode
<br>
When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_SS port
<br>
After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.
<br>
</div></td></tr><tr><td>
[31]</td><td>WKCLKEN</td><td><div style="word-wrap: break-word;"><b>Wake-up by SPI Clock Enable Bit
</b><br>
0 = Wake-up function Disabled.
<br>
1 = Wake-up function Enabled.
<br>
Note: When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_CLK port
<br>
After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23393">23393</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a42bd75cdeab853186f7fecead2e77f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bd75cdeab853186f7fecead2e77f97">&#9670;&nbsp;</a></span>FIFOCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::FIFOCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x003c] SPI FIFO Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FIFOCTL
</font><br><p> <font size="2">
Offset: 0x3C  SPI FIFO Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXFBCLR</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Clear
</b><br>
0 = No clear the received FIFO.
<br>
1 = Clear the received FIFO.
<br>
Note: This bit is used to clear the receiver counter in FIFO Mode
<br>
This bit can be written 1 to clear the receiver counter and this bit will be cleared to 0 automatically after clearing receiving counter
<br>
After the clear operation, the flag of RXEMPTY in SPI_STATUS[0] will be set to 1.
<br>
</div></td></tr><tr><td>
[1]</td><td>TXFBCLR</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Clear
</b><br>
0 = Not clear the transmitted FIFO.
<br>
1 = Clear the transmitted FIFO.
<br>
Note: This bit is used to clear the transmit counter in FIFO Mode
<br>
This bit can be written 1 to clear the transmitting counter and this bit will be cleared to 0 automatically after clearing transmitting counter
<br>
After the clear operation, the flag of TXEMPTY in SPI_STATUS[2] will be set to 1.
<br>
</div></td></tr><tr><td>
[2]</td><td>RXTHIEN</td><td><div style="word-wrap: break-word;"><b>Receive Threshold Interrupt Enable Bit
</b><br>
0 = RX threshold interrupt Disabled.
<br>
1 = RX threshold interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>TXTHIEN</td><td><div style="word-wrap: break-word;"><b>Transmit Threshold Interrupt Enable Bit
</b><br>
0 = TX threshold interrupt Disabled.
<br>
1 = TX threshold interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>RXOVIEN</td><td><div style="word-wrap: break-word;"><b>Receive FIFO over Run Interrupt Enable Bit
</b><br>
0 = RX FIFO over run interrupt Disabled.
<br>
1 = RX FIFO over run interrupt Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>RXTOIEN</td><td><div style="word-wrap: break-word;"><b>RX Read Time Out Interrupt Enable Bit
</b><br>
0 = RX read Timeout Interrupt Disabled.
<br>
1 = RX read Timeout Interrupt Enabled.
<br>
</div></td></tr><tr><td>
[26:24]</td><td>RXTH</td><td><div style="word-wrap: break-word;"><b>Received FIFO Threshold
</b><br>
If RX valid data counts are greater than RXTH, RXTHIF (SPI_STATUS[8]) will be set to 1.
<br>
</div></td></tr><tr><td>
[30:28]</td><td>TXTH</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Threshold
</b><br>
If TX valid data counts are smaller than or equal to TXTH, TXTHIF (SPI_STATUS[10]) will be set to 1.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23408">23408</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a70facf25a25f16b8d817cc8a5efee378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70facf25a25f16b8d817cc8a5efee378">&#9670;&nbsp;</a></span>PDMACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::PDMACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0038] SPI PDMA Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PDMACTL
</font><br><p> <font size="2">
Offset: 0x38  SPI PDMA Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>TXPDMAEN</td><td><div style="word-wrap: break-word;"><b>Transmit PDMA Enable Bit
</b><br>
0 = Transmit PDMA function Disabled.
<br>
1 = Transmit PDMA function Enabled.
<br>
Refer to PDMA section for more detail information.
<br>
SPI_CTL Note:
<br>
1
<br>
Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.
<br>
2
<br>
If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.
<br>
Hardware will clear this bit to 0 automatically after PDMA transfer done.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXPDMAEN</td><td><div style="word-wrap: break-word;"><b>Receiving PDMA Enable Bit
</b><br>
0 = Receiver PDMA function Disabled.
<br>
1 = Receiver PDMA function Enabled.
<br>
Refer to PDMA section for more detail information.
<br>
Note:
<br>
Hardware will clear this bit to 0 automatically after PDMA transfer done.
<br>
In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock
<br>
</div></td></tr><tr><td>
[2]</td><td>PDMARST</td><td><div style="word-wrap: break-word;"><b>PDMA Reset
</b><br>
It is used to reset the SPI PDMA function into default state.
<br>
0 = After reset PDMA function or in normal operation.
<br>
1 = Reset PDMA function.
<br>
Note: it is auto cleared to 0 after the reset function has done.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23407">23407</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a0f90ba390534a31dbf6d59579bc58e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f90ba390534a31dbf6d59579bc58e8d">&#9670;&nbsp;</a></span>RX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::RX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0010] SPI Receive Data FIFO Register 0</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RX0
</font><br><p> <font size="2">
Offset: 0x10  SPI Receive Data FIFO Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>RX</td><td><div style="word-wrap: break-word;"><b>Receive Data Register (Read Only)
</b><br>
The received data can be read on it
<br>
If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.
<br>
Note: The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22]) is set 1
<br>
The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode
<br>
SPI_RX0 shall be read first in TWOBIT mode.
<br>
In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23397">23397</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a65a390675b7ba49bcf6c68083acc8742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a390675b7ba49bcf6c68083acc8742">&#9670;&nbsp;</a></span>RX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::RX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0014] SPI Receive Data FIFO Register 1</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RX1
</font><br><p> <font size="2">
Offset: 0x14  SPI Receive Data FIFO Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>RX</td><td><div style="word-wrap: break-word;"><b>Receive Data Register (Read Only)
</b><br>
The received data can be read on it
<br>
If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.
<br>
Note: The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22]) is set 1
<br>
The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode
<br>
SPI_RX0 shall be read first in TWOBIT mode.
<br>
In FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23398">23398</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a8ced326eafea489fe145d80d96ac0cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ced326eafea489fe145d80d96ac0cab">&#9670;&nbsp;</a></span>SSCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::SSCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x000c] SPI Slave Select Control Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SSCTL
</font><br><p> <font size="2">
Offset: 0x0C  SPI Slave Select Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>SS</td><td><div style="word-wrap: break-word;"><b>Slave Selection Control (Master Only)
</b><br>
If AUTOSS bit (SPI_SSCTL[3]) is cleared, writing 1 to SS[0] (SPI_CTL[0]) bit sets the SPI_SS0 line to an active state and writing 0 sets the line back to inactive state (the same as SPI_CTL[1] for SPI_SS1).
<br>
If AUTOSS = 0,.
<br>
00 = Both SPI_SS1 and SPI_SS0 are inactive.
<br>
01 = SPI_SS1 is inactive, SPI_SS0 is active.
<br>
10 = SPI_SS1 is active, SPI_SS0 is inactive.
<br>
11 = Both SPI_SS1 and SPI_SS0 are active.
<br>
If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPI_SS0/SPI_SS1 line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time
<br>
(The active level of SPI_SS1/SPI_SS0 is specified in SSACTPOL).
<br>
If AUTOSS =1,.
<br>
00 = Both SPI_SS1 and SPI_SS0 are inactive.
<br>
01 = SPI_SS1 is inactive, SPI_SS0 is active on the duration of transaction.
<br>
10 = SPI_SS1 is active on the duration of transaction, SPI_SS0 is inactive.
<br>
11 = Both SPI_SS1 and SPI_SS0 are active on the duration of transaction.
<br>
Note:
<br>
1. This interface can only drive one device/slave at a given time. Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.
<br>
2. SPI_SS0 is also defined as device/slave select input in Slave mode
<br>
And that the slave select input must be driven by edge active trigger which level depend on the SSACTPOL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software
<br>
</div></td></tr><tr><td>
[2]</td><td>SSACTPOL</td><td><div style="word-wrap: break-word;"><b>Slave Selection Active Polarity
</b><br>
It defines the active polarity of slave selection signal (SPI_SS[1:0]).
<br>
0 = The SPI_SS slave select signal is active Low.
<br>
1 = The SPI_SS slave select signal is active High.
<br>
</div></td></tr><tr><td>
[3]</td><td>AUTOSS</td><td><div style="word-wrap: break-word;"><b>Automatic Slave Selection Function Enable Bit (Master Only)
</b><br>
0 = If this bit is set as 0, slave select signals are asserted and de-asserted by setting and clearing related bits in SS[1:0] (SPI_CTL[1:0]).
<br>
1 = If this bit is set as 1, SPI_SS0 and SPI_SS1 signals are generated automatically
<br>
It means that device/slave select signal, which is set in SS[1:0] (SPI_CTL[1:0]) is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done.
<br>
</div></td></tr><tr><td>
[4]</td><td>SSLTRIG</td><td><div style="word-wrap: break-word;"><b>Slave Select Level Trigger Control
</b><br>
0 = The input slave select signal is edge-trigger.
<br>
1 = The slave select signal will be level-trigger
<br>
It depends on SSACTPOL to decide the signal is active low or active high.
<br>
</div></td></tr><tr><td>
[5]</td><td>SLV3WIRE</td><td><div style="word-wrap: break-word;"><b>Slave 3-wire Mode Enable Bit
</b><br>
This bit is used to ignore the slave select signal in Slave mode
<br>
The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.
<br>
0 = The controller is 4-wire bi-direction interface.
<br>
1 = The controller is 3-wire bi-direction interface in Slave mode
<br>
When this bit is set as 1, the controller start to transmit/receive data after the GOBUSY bit active and the SPI clock input.
<br>
Note 1: Refer to No Slave Select Mode.
<br>
Note 2: In no slave select signal mode, hardware will set the SSLTRIG (SPI_SSCTL[4]) as 1 automatically.
<br>
</div></td></tr><tr><td>
[6]</td><td>SLVTOIEN</td><td><div style="word-wrap: break-word;"><b>Slave Time-out Interrupt Enable Bit
</b><br>
This bit is used to enable the slave time-out function in slave mode and there will be an interrupt if slave time-out event occur
<br>
0 = Slave time-out function and interrupt both Disabled.
<br>
1 = Slave time-out function and interrupt both Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>SLVABORT</td><td><div style="word-wrap: break-word;"><b>Abort in Slave Mode with No Slave Selected
</b><br>
0 = No force the slave abort.
<br>
1 = Force the current transfer done in no slave select mode.
<br>
Refer to No Slave Select Mode.
<br>
Note: It is auto cleared to 0 by hardware when the abort event is active.
<br>
</div></td></tr><tr><td>
[9]</td><td>SSTAIEN</td><td><div style="word-wrap: break-word;"><b>Slave Start Interrupt Enable Bit
</b><br>
0 = Transfer start interrupt Disabled in no slave select mode.
<br>
1 = Transaction start interrupt Enabled in no slave select mode
<br>
It is cleared when the current transfer done or the SLVSTAIF bit cleared (write 1 clear).
<br>
Refer to No Slave Select Mode.
<br>
</div></td></tr><tr><td>
[16]</td><td>SSINAIEN</td><td><div style="word-wrap: break-word;"><b>Slave Select Inactive Interrupt Enable Bit
</b><br>
It is used to enable the interrupt when the transfer has done in slave mode.
<br>
0 = No any interrupt, even there is slave select inactive event.
<br>
1 = There is interrupt event when the slave select becomes inactive from active condition
<br>
It is used to inform the user to know that the transaction has finished and the slave select into the inactive state.
<br>
</div></td></tr><tr><td>
[29:20]</td><td>SLVTOCNT</td><td><div style="word-wrap: break-word;"><b>Slave Mode Time-out Period
</b><br>
In Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active
<br>
The clock source of the time-out counter is Slave peripheral clock
<br>
If the value is 0, it indicates the slave mode time-out function is disabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23396">23396</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a463a7dc0398240e38e1c356316e79a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a7dc0398240e38e1c356316e79a4d">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0004] SPI Status Register</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS
</font><br><p> <font size="2">
Offset: 0x04  SPI Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXEMPTY</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = Received data FIFO is not empty in the FIFO mode.
<br>
1 = Received data FIFO is empty in the FIFO mode.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXFULL</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Buffer Full Indicator (Read Only)
</b><br>
0 = Received data FIFO is not full in FIFO mode.
<br>
1 = Received data FIFO is full in the FIFO mode.
<br>
</div></td></tr><tr><td>
[2]</td><td>TXEMPTY</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Empty Indicator (Read Only)
</b><br>
0 = Transmitted data FIFO is not empty in the FIFO mode.
<br>
1 =Transmitted data FIFO is empty in the FIFO mode.
<br>
</div></td></tr><tr><td>
[3]</td><td>TXFULL</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Buffer Full Indicator (Read Only)
</b><br>
0 = Transmitted data FIFO is not full in the FIFO mode.
<br>
1 = Transmitted data FIFO is full in the FIFO mode.
<br>
</div></td></tr><tr><td>
[4]</td><td>LTRIGF</td><td><div style="word-wrap: break-word;"><b>Level Trigger Accomplish Flag (Read Only)
</b><br>
In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.
<br>
0 = The transferred bit length of one transaction does not meet the specified requirement.
<br>
1 = The transferred bit length meets the specified requirement which defined in DWIDTH.
<br>
Note: This bit is READ only
<br>
As the software sets the GOBUSY bit to 1, the LTRIGF will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period
<br>
In FIFO mode, this bit is unmeaning.
<br>
</div></td></tr><tr><td>
[6]</td><td>SLVSTAIF</td><td><div style="word-wrap: break-word;"><b>Slave Start Interrupt Flag
</b><br>
It is used to dedicate that the transfer has started in Slave mode with no slave select.
<br>
0 = Slave started transfer no active.
<br>
1 = Transfer has started in Slave mode with no slave select
<br>
It is automatically cleared by transfer done or writing '1'.
<br>
</div></td></tr><tr><td>
[7]</td><td>UNITIF</td><td><div style="word-wrap: break-word;"><b>Unit Transfer Interrupt Flag
</b><br>
0 = No transaction has been finished since this bit was cleared to 0.
<br>
1 = SPI controller has finished one unit transfer.
<br>
Note 1: This bit will be cleared by writing 1 to it.
<br>
0 = Transfer is not finished yet.
<br>
1 = Transfer is done. The interrupt is requested when the UNITIEN (SPI_CTL[17]) bit is enabled.
<br>
Note 2: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[8]</td><td>RXTHIF</td><td><div style="word-wrap: break-word;"><b>RX FIFO Threshold Interrupt Flag (Read Only)
</b><br>
0 = RX valid data counts small or equal than RXTH (SPI_FIFOCTL[27:24]).
<br>
1 = RX valid data counts bigger than RXTH.
<br>
Note: If RXTHIEN(SPI_FIFOCTL[2]) = 1 and RXTHIF = 1, SPI will generate interrupt.
<br>
</div></td></tr><tr><td>
[9]</td><td>RXOVIF</td><td><div style="word-wrap: break-word;"><b>Receive FIFO over Run Interrupt Flag
</b><br>
0 = No FIFO over run.
<br>
1 = Receive FIFO over run.
<br>
Note 1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will be dropped.
<br>
Note 2: This bit will be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[10]</td><td>TXTHIF</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Threshold Interrupt Flag (Read Only)
</b><br>
0 = TX valid data counts bigger than TXTH (SPI_FIFOCTL[31:28]).
<br>
1 = TX valid data counts small or equal than TXTH.
<br>
</div></td></tr><tr><td>
[12]</td><td>RXTOIF</td><td><div style="word-wrap: break-word;"><b>Receive Time-out Interrupt Flag
</b><br>
0 = There is not timeout event on the received buffer.
<br>
1 = Time out event active in RX FIFO is not empty.
<br>
Refer to Time Out section.
<br>
Note: This bit will be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[13]</td><td>SLVTOIF</td><td><div style="word-wrap: break-word;"><b>Slave Time-out Interrupt Flag
</b><br>
If SLVTOIEN (SPI_SSCTL[6]) is set to 1, this bit will be asserted when slave time-out event occur
<br>
Software can clear this bit by setting RXFBCLR (SPI_FIFOCTL[0]) or writing 1 to clear this bit.
<br>
0 = Slave time-out does not occur yet.
<br>
1 = Slave time-out has occurred.
<br>
</div></td></tr><tr><td>
[15]</td><td>SLVTXSKE</td><td><div style="word-wrap: break-word;"><b>Slave Mode Transmit Skew Buffer Empty Status
</b><br>
This bit indicates the empty status of transmit skew buffer which is used in Slave mode.
<br>
</div></td></tr><tr><td>
[19:16]</td><td>RXCNT</td><td><div style="word-wrap: break-word;"><b>Receive FIFO Data Counts (Read Only)
</b><br>
This bit field indicates the valid data count of receive FIFO buffer.
<br>
</div></td></tr><tr><td>
[23:20]</td><td>TXCNT</td><td><div style="word-wrap: break-word;"><b>Transmit FIFO Data Counts (Read Only)
</b><br>
This bit field indicates the valid data count of transmit FIFO buffer.
<br>
</div></td></tr><tr><td>
[30]</td><td>WKSSIF</td><td><div style="word-wrap: break-word;"><b>Wake-up by Slave Select Interrupt Flag
</b><br>
When chip is woken up from Power-down mode by the toggle event on SPI_SS port, this bit is set to 1
<br>
This bit can be cleared by writing '1' to it.
<br>
</div></td></tr><tr><td>
[31]</td><td>WKCLKIF</td><td><div style="word-wrap: break-word;"><b>Wake-up by SPI Clock Interrupt Flag
</b><br>
When chip is woken up from Power-down mode by the toggle event on SPI_CLK port, this bit is set to 1
<br>
This bit can be cleared by writing '1' to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23394">23394</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="af07b33f2435790396bd6b24fae145f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07b33f2435790396bd6b24fae145f71">&#9670;&nbsp;</a></span>TX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::TX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0020] SPI Transmit Data FIFO Register 0</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TX0
</font><br><p> <font size="2">
Offset: 0x20  SPI Transmit Data FIFO Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>TX</td><td><div style="word-wrap: break-word;"><b>Transmit Data Register (Write Only)
</b><br>
The Data Transmit Registers hold the data to be transmitted in the next transfer
<br>
The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.
<br>
For example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer
<br>
If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.
<br>
Note:
<br>
1.
<br>
The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22]) is set 1
<br>
The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode
<br>
SPI_TX0 shall be written first in TWOBIT mode.
<br>
In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.
<br>
2.
<br>
If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23402">23402</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a2956855bd2082e1cba653490856ba72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2956855bd2082e1cba653490856ba72f">&#9670;&nbsp;</a></span>TX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPI_T::TX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0024] SPI Transmit Data FIFO Register 1</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TX1
</font><br><p> <font size="2">
Offset: 0x24  SPI Transmit Data FIFO Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[31:0]</td><td>TX</td><td><div style="word-wrap: break-word;"><b>Transmit Data Register (Write Only)
</b><br>
The Data Transmit Registers hold the data to be transmitted in the next transfer
<br>
The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.
<br>
For example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer
<br>
If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.
<br>
Note:
<br>
1
<br>
The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22]) is set 1
<br>
The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode
<br>
SPI_TX0 shall be written first in TWOBIT mode.
<br>
In FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.
<br>
2
<br>
If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l23403">23403</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano103bsp/Library/Device/Nuvoton/Nano103/Include/<a class="el" href="_nano103_8h_source.html">Nano103.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 7 2019 13:29:37 for Nano103 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
