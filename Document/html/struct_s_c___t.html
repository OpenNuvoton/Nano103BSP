<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano103 BSP: SC_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano103 BSP
   &#160;<span id="projectnumber">V3.01.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano103 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SC_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano103_8h_source.html">Nano103.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a08b9392001378ff1d731861a5eda5d7d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a08b9392001378ff1d731861a5eda5d7d">DAT</a></td></tr>
<tr class="separator:a08b9392001378ff1d731861a5eda5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7098b2e65c064be85bd9349eeb8465"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a5d7098b2e65c064be85bd9349eeb8465">CTL</a></td></tr>
<tr class="separator:a5d7098b2e65c064be85bd9349eeb8465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1c60adf67f1b3cc6602a972c2cb29f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a1f1c60adf67f1b3cc6602a972c2cb29f">ALTCTL</a></td></tr>
<tr class="separator:a1f1c60adf67f1b3cc6602a972c2cb29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24513a3f822d239e34bdf15165af5ae"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#ae24513a3f822d239e34bdf15165af5ae">EGT</a></td></tr>
<tr class="separator:ae24513a3f822d239e34bdf15165af5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c1bc739dc56f6b842cd80a44a70515"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#ad4c1bc739dc56f6b842cd80a44a70515">RXTOUT</a></td></tr>
<tr class="separator:ad4c1bc739dc56f6b842cd80a44a70515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21fcbc41c567481506ac04a41bf52e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a2a21fcbc41c567481506ac04a41bf52e">ETUCTL</a></td></tr>
<tr class="separator:a2a21fcbc41c567481506ac04a41bf52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50538e16985f66771d5464743feb1b7a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a50538e16985f66771d5464743feb1b7a">INTEN</a></td></tr>
<tr class="separator:a50538e16985f66771d5464743feb1b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeadbb0ba51539b0c2de4ad947fb0a8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#aadeadbb0ba51539b0c2de4ad947fb0a8">INTSTS</a></td></tr>
<tr class="separator:aadeadbb0ba51539b0c2de4ad947fb0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763cbd039f818865fc97569ebfb553e3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a763cbd039f818865fc97569ebfb553e3">STATUS</a></td></tr>
<tr class="separator:a763cbd039f818865fc97569ebfb553e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c045cb802cc04954a95356c2308ce4c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a7c045cb802cc04954a95356c2308ce4c">PINCTL</a></td></tr>
<tr class="separator:a7c045cb802cc04954a95356c2308ce4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a7f9dd18f1316d1fd3faf6e9f5c2d0d3d">TMRCTL0</a></td></tr>
<tr class="separator:a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ec89f4fa30ee9e8c6480abf814d849"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a93ec89f4fa30ee9e8c6480abf814d849">TMRCTL1</a></td></tr>
<tr class="separator:a93ec89f4fa30ee9e8c6480abf814d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c05c3ae1f45e417764abe3ab1d769c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a12c05c3ae1f45e417764abe3ab1d769c">TMRCTL2</a></td></tr>
<tr class="separator:a12c05c3ae1f45e417764abe3ab1d769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea818bd8186138fa212ebf17ffbd8d5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#aaea818bd8186138fa212ebf17ffbd8d5">UARTCTL</a></td></tr>
<tr class="separator:aaea818bd8186138fa212ebf17ffbd8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546855d83fc95705c702c683d5935fcb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a546855d83fc95705c702c683d5935fcb">ACTCTL</a></td></tr>
<tr class="separator:a546855d83fc95705c702c683d5935fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SC Smart Card Host Interface Controller(SC)
Memory Mapped Structure for SC Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l20422">20422</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a546855d83fc95705c702c683d5935fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546855d83fc95705c702c683d5935fcb">&#9670;&nbsp;</a></span>ACTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ACTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0040] SC Activation Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ACTCTL
</font><br><p> <font size="2">
Offset: 0x40  SC Activation Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[4:0]</td><td>T1EXT</td><td><div style="word-wrap: break-word;"><b>Configurable Cycles T1EXT in Hardware Activation
</b><br>
This field provide the configurable cycles to extend the Activation time T1
<br>
The cycle scaling factor is 2048.
<br>
Extend cycles = (filled value * 2048) cycles.
<br>
Refer to SC Activation Sequence in Figure 6.15-4 SC Activation Sequence.
<br>
For example,
<br>
SCLK = 4Mhz, each cycle = 0.25us,.
<br>
Filled 20 to this field
<br>
Extend time = 20*2048*0.25us = 10.24 ms.
<br>
Note: setting 0 to this field conforms to the protocol ISO/IEC 7816-3
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21653">21653</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a1f1c60adf67f1b3cc6602a972c2cb29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c60adf67f1b3cc6602a972c2cb29f">&#9670;&nbsp;</a></span>ALTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0008] SC Alternate Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ALTCTL
</font><br><p> <font size="2">
Offset: 0x08  SC Alternate Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>TXRST</td><td><div style="word-wrap: break-word;"><b>TX Software Reset
</b><br>
When TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
<br>
0 = No effect.
<br>
1 = Reset the TX internal state machine and pointers.
<br>
Note: This bit will be auto cleared after reset is complete.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXRST</td><td><div style="word-wrap: break-word;"><b>Rx Software Reset
</b><br>
When RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.
<br>
0 = No effect.
<br>
1 = Reset the Rx internal state machine and pointers.
<br>
Note: This bit will be auto cleared after reset is complete.
<br>
</div></td></tr><tr><td>
[2]</td><td>DACTEN</td><td><div style="word-wrap: break-word;"><b>Deactivation Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by deactivation sequence
<br>
0 = No effect.
<br>
1 = Deactivation sequence generator Enabled.
<br>
Note1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
<br>
Note2: This field will be cleared by TXRST (SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.
<br>
Note3: If SCEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[3]</td><td>ACTEN</td><td><div style="word-wrap: break-word;"><b>Activation Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by activation sequence
<br>
0 = No effect.
<br>
1 = Activation sequence generator Enabled.
<br>
Note1: When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.
<br>
Note2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
<br>
Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[4]</td><td>WARSTEN</td><td><div style="word-wrap: break-word;"><b>Warm Reset Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by warm reset sequence
<br>
0 = No effect.
<br>
1 = Warm reset sequence generator Enabled.
<br>
Note1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.
<br>
Note2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.
<br>
Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[5]</td><td>CNTEN0</td><td><div style="word-wrap: break-word;"><b>Internal Timer0 Start Enable Bit
</b><br>
This bit enables Timer 0 to start counting
<br>
Software can fill 0 to stop it and set 1 to reload and count.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 24 bit timer when TMRSEL (SC_CTL[14:13]) = 11,01,10.
<br>
Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
<br>
Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[6]</td><td>CNTEN1</td><td><div style="word-wrap: break-word;"><b>Internal Timer1 Start Enable Bit
</b><br>
This bit enables Timer 1 to start counting
<br>
Software can fill 0 to stop it and set 1 to reload and count.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 11
<br>
Do not fill in CNTEN1 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01.
<br>
Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
<br>
Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[7]</td><td>CNTEN2</td><td><div style="word-wrap: break-word;"><b>Internal Timer2 Start Enable Bit
</b><br>
This bit enables Timer 2 to start counting
<br>
Software can fill 0 to stop it and set 1 to reload and count.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 11
<br>
Do not fill in CNTEN2 when TMRSEL(SC_CTL[14:13])= 00 or TMRSEL(SC_CTL[14:13]) = 01 or TMRSEL(SC_CTL[14:13]) = 10.
<br>
Note2: If the operation mode is not in auto-reload mode (SC_TMRCTL2[26] = 0), this bit will be auto-cleared by hardware.
<br>
Note3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>INITSEL</td><td><div style="word-wrap: break-word;"><b>Initial Timing Selection
</b><br>
This fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).
<br>
Unit: SC clock
<br>
Activation: Refer to SC Activation Sequence in Figure 6.15-4 SC Activation Sequence.
<br>
Warm-reset: Refer to Warm-Reset Sequence in Figure 6.15-5 SC Warm Reset Sequence
<br>
Deactivation: Refer to Deactivation Sequence in Figure 6.15-6 SC Deactivation Sequence
<br>
Note: When set Activation and Warm reset in mode 11, it may have deviation at most 128 cycles.
<br>
</div></td></tr><tr><td>
[12]</td><td>RXBGTEN</td><td><div style="word-wrap: break-word;"><b>Receiver Block Guard Time Function Enable Bit
</b><br>
0 = Receiver block guard time function Disabled.
<br>
1 = Receiver block guard time function Enabled.
<br>
</div></td></tr><tr><td>
[13]</td><td>ACTSTS0</td><td><div style="word-wrap: break-word;"><b>Internal Timer0 Active State (Read Only)
</b><br>
This bit indicates the timer counter status of timer0.
<br>
0 = Timer0 is not active.
<br>
1 = Timer0 is active.
<br>
Note: Timer0 is active does not always mean timer0 is counting the CNT(SC_TMRCTL0[23:0]).
<br>
</div></td></tr><tr><td>
[14]</td><td>ACTSTS1</td><td><div style="word-wrap: break-word;"><b>Internal Timer1 Active State (Read Only)
</b><br>
This bit indicates the timer counter status of timer1.
<br>
0 = Timer1 is not active.
<br>
1 = Timer1 is active.
<br>
Note: Timer1 is active does not always mean timer1 is counting the CNT(SC_TMRCTL1[7:0]).
<br>
</div></td></tr><tr><td>
[15]</td><td>ACTSTS2</td><td><div style="word-wrap: break-word;"><b>Internal Timer2 Active State (Read Only)
</b><br>
This bit indicates the timer counter status of timer2.
<br>
0 = Timer2 is not active.
<br>
1 = Timer2 is active.
<br>
Note: Timer2 is active does not always mean timer2 is counting the CNT(SC_TMRCTL2[7:0]).
<br>
</div></td></tr><tr><td>
[16]</td><td>OUTSEL</td><td><div style="word-wrap: break-word;"><b>Smartcard Data Pin Output Mode Selection
</b><br>
Use this bit to select smartcard data pin output mode.
<br>
0 = Quasi mode.
<br>
1 = Open-drain mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21638">21638</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a5d7098b2e65c064be85bd9349eeb8465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7098b2e65c064be85bd9349eeb8465">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0004] SC Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL
</font><br><p> <font size="2">
Offset: 0x04  SC Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SCEN</td><td><div style="word-wrap: break-word;"><b>SC Engine Enable Bit
</b><br>
Set this bit to 1 to enable SC operation
<br>
If this bit is cleared, SC will force all transition to IDLE state
<br>
Note1: SCEN must be set to 1 before filling in other registers, or smart card will not work properly.
<br>
Note2: If SCEN is activated, all function can work correctly
<br>
If SCEN is not activated, when CPU write data to SMC, only Flip-flop which works in PCLK domain will turn on for two PCLK cycle, Flip-flop working in SCLK domain will not be turn on.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXOFF</td><td><div style="word-wrap: break-word;"><b>RX Transition Disable Bit
</b><br>
0 = The receiver Enabled.
<br>
1 = The receiver Disabled.
<br>
Note1: If AUTOCEN (SC_CTL[3])is enabled, these fields must be ignored.
<br>
Note2: After hardware activation and hardware warm reset are done, RXOFF is set to 0 automatically.
<br>
</div></td></tr><tr><td>
[2]</td><td>TXOFF</td><td><div style="word-wrap: break-word;"><b>TX Transition Disable Bit
</b><br>
0 = The transceiver Enabled.
<br>
1 = The transceiver Disabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>AUTOCEN</td><td><div style="word-wrap: break-word;"><b>Auto Convention Enable Bit
</b><br>
0 = Auto-convention Disabled.
<br>
1 = Auto-convention Enabled
<br>
When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11.
<br>
If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 0x3B or 0x3F
<br>
After hardware received first data and stored it at buffer, hardware will decided the convention and change the CONSEL (SC_CTL[5:4]) bits automatically
<br>
If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR (if ACERRIEN (SC_INTEN[10]) = 1 to CPU.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>CONSEL</td><td><div style="word-wrap: break-word;"><b>Convention Selection
</b><br>
00 = Direct convention.
<br>
01 = Reserved.
<br>
10 = Reserved.
<br>
11 = Inverse convention.
<br>
Note: If AUTOCEN(SC_CTL[3]) is enabled, this field is ignored.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RXTRGLV</td><td><div style="word-wrap: break-word;"><b>Rx Buffer Trigger Level
</b><br>
When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set (if [RDAIEN](SC_INTEN[0])  is enabled, an interrupt will be generated).
<br>
00 = INTR_RDA Trigger Level with 01 Bytes.
<br>
01 = INTR_RDA Trigger Level with 02 Bytes.
<br>
10 = INTR_RDA Trigger Level with 03 Bytes.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[12:8]</td><td>BGT</td><td><div style="word-wrap: break-word;"><b>Block Guard Time (BGT)
</b><br>
Block guard time means the minimum bit length between the leading edges of two consecutive characters between different transfer directions
<br>
This field indicates the counter for the bit length of block guard time
<br>
According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
<br>
Note: The real block guard time is BGT + 1.
<br>
</div></td></tr><tr><td>
[14:13]</td><td>TMRSEL</td><td><div style="word-wrap: break-word;"><b>Timer Selection
</b><br>
00 = All internal timer function Disabled.
<br>
11 = Internal 24 bit timer and two 8 bit timers Enabled
<br>
Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0].
<br>
Other configurations are reserved
<br>
</div></td></tr><tr><td>
[15]</td><td>NSB</td><td><div style="word-wrap: break-word;"><b>Stop Bit Length
</b><br>
This field indicates the length of stop bit.
<br>
0 = The stop bit length is 2 ETU.
<br>
1= The stop bit length is 1 ETU.
<br>
Note: The default stop bit length is 2. SMC and UART adopt NSB to program the stop bit length.
<br>
</div></td></tr><tr><td>
[18:16]</td><td>RXRTY</td><td><div style="word-wrap: break-word;"><b>RX Error Retry Count Number
</b><br>
This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
<br>
Note1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.
<br>
Note2: This field cannot be changed when RX_ERETRY_EN enabled
<br>
The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.
<br>
</div></td></tr><tr><td>
[19]</td><td>RXRTYEN</td><td><div style="word-wrap: break-word;"><b>RX Error Retry Enable Bit
</b><br>
This bit enables receiver retry function when parity error has occurred.
<br>
0 = RX error retry function Disabled.
<br>
1 = RX error retry function Enabled.
<br>
Note: Software must fill in the RXRTY value before enabling this bit.
<br>
</div></td></tr><tr><td>
[22:20]</td><td>TXRTY</td><td><div style="word-wrap: break-word;"><b>TX Error Retry Count Number
</b><br>
This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
<br>
Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
<br>
Note2: This field cannot be changed when TXRTYEN enabled
<br>
The change flow is to disable TXRTYEN first and then fill in new retry value.
<br>
</div></td></tr><tr><td>
[23]</td><td>TXRTYEN</td><td><div style="word-wrap: break-word;"><b>TX Error Retry Enable Bit
</b><br>
This bit enables transmitter retry function when parity error has occurred.
<br>
0 = TX error retry function Disabled.
<br>
1 = TX error retry function Enabled.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>CDDBSEL</td><td><div style="word-wrap: break-word;"><b>Card Detect De-bounce Selection
</b><br>
This field indicates the card detect de-bounce selection.
<br>
00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks.
<br>
Other configurations are reserved.
<br>
</div></td></tr><tr><td>
[30]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator(Read Only)
</b><br>
Due to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.SYNC flag is
<br>
0 = synchronizing is completion, user can write new data to RXRTY and TXRTY.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21637">21637</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a08b9392001378ff1d731861a5eda5d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b9392001378ff1d731861a5eda5d7d">&#9670;&nbsp;</a></span>DAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0000] SC Receive/Transmit Holding Buffer Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DAT
</font><br><p> <font size="2">
Offset: 0x00  SC Receive/Transmit Holding Buffer Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DAT</td><td><div style="word-wrap: break-word;"><b>Receive/Transmit Holding Buffer
</b><br>
Write Operation:
<br>
By writing data to DAT, the SC will send out an 8-bit data.
<br>
Note: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.
<br>
Read Operation:
<br>
By reading DAT, the SC will return an 8-bit received data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21636">21636</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ae24513a3f822d239e34bdf15165af5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24513a3f822d239e34bdf15165af5ae">&#9670;&nbsp;</a></span>EGT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::EGT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x000c] SC Extra Guard Time Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">EGT
</font><br><p> <font size="2">
Offset: 0x0C  SC Extra Guard Time Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>EGT</td><td><div style="word-wrap: break-word;"><b>Extra Guard Time
</b><br>
This field indicates the extra guard timer value.
<br>
Note: The counter is ETU base .
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21639">21639</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a2a21fcbc41c567481506ac04a41bf52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a21fcbc41c567481506ac04a41bf52e">&#9670;&nbsp;</a></span>ETUCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ETUCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0014] SC Element Time Unit Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ETUCTL
</font><br><p> <font size="2">
Offset: 0x14  SC Element Time Unit Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[11:0]</td><td>ETURDIV</td><td><div style="word-wrap: break-word;"><b>ETU Rate Divider
</b><br>
The field indicates the clock rate divider.
<br>
The real ETU is ETURDIV + 1.
<br>
Note: Software can configure this field, but this field must be greater than 0x004.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21641">21641</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a50538e16985f66771d5464743feb1b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50538e16985f66771d5464743feb1b7a">&#9670;&nbsp;</a></span>INTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0018] SC Interrupt Enable Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN
</font><br><p> <font size="2">
Offset: 0x18  SC Interrupt Enable Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIEN</td><td><div style="word-wrap: break-word;"><b>Receive Data Reach Interrupt Enable Bit
</b><br>
This field is used to enable received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt.
<br>
0 = Receive data reach trigger level interrupt Disabled.
<br>
1 = Receive data reach trigger level interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>TBEIEN</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Interrupt Enable Bit
</b><br>
This field is used to enable transmit buffer empty interrupt.
<br>
0 = Transmit buffer empty interrupt Disabled.
<br>
1 = Transmit buffer empty interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>TERRIEN</td><td><div style="word-wrap: break-word;"><b>Transfer Error Interrupt Enable Bit
</b><br>
This field is used to enable transfer error interrupt
<br>
The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR (SC_STATUS[30]).
<br>
0 = Transfer error interrupt Disabled.
<br>
1 = Transfer error interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR0IEN</td><td><div style="word-wrap: break-word;"><b>Timer0 Interrupt Enable Bit
</b><br>
This field is used to enable TMR0 interrupt.
<br>
0 = Timer0 interrupt Disabled.
<br>
1 = Timer0 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR1IEN</td><td><div style="word-wrap: break-word;"><b>Timer1 Interrupt Enable Bit
</b><br>
This field is used to enable the TMR1 interrupt.
<br>
0 = Timer1 interrupt Disabled.
<br>
1 = Timer1 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR2IEN</td><td><div style="word-wrap: break-word;"><b>Timer2 Interrupt Enable Bit
</b><br>
This field is used to enable TMR2 interrupt.
<br>
0 = Timer2 interrupt Disabled.
<br>
1 = Timer2 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>BGTIEN</td><td><div style="word-wrap: break-word;"><b>Block Guard Time Interrupt Enable Bit
</b><br>
This field is used to enable block guard time interrupt.
<br>
0 = Block guard time Disabled.
<br>
1 = Block guard time Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>CDIEN</td><td><div style="word-wrap: break-word;"><b>Card Detect Interrupt Enable Bit
</b><br>
This field is used to enable card detect interrupt. The card detect status is CINSERT(SC_STATUS[12])
<br>
0 = Card detect interrupt Disabled.
<br>
1 = Card detect interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>INITIEN</td><td><div style="word-wrap: break-word;"><b>Initial End Interrupt Enable Bit
</b><br>
This field is used to enable activation (ACTEN(SC_ALTCTL[3] = 1)), deactivation ((DACTEN SC_ALTCTL[2]) = 1) and warm reset (WARSTEN (SC_ALTCTL [4])) sequence interrupt.
<br>
0 = Initial end interrupt Disabled.
<br>
1 = Initial end interrupt Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>RXTOIEN</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Time-out Interrupt Enable Bit
</b><br>
This field is used to enable receiver buffer time-out interrupt.
<br>
0 = Receiver buffer time-out interrupt Disabled.
<br>
1 = Receiver buffer time-out interrupt Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>ACERRIEN</td><td><div style="word-wrap: break-word;"><b>Auto Convention Error Interrupt Enable Bit
</b><br>
This field is used to enable auto-convention error interrupt.
<br>
0 = Auto-convention error interrupt Disabled.
<br>
1 = Auto-convention error interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21642">21642</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aadeadbb0ba51539b0c2de4ad947fb0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeadbb0ba51539b0c2de4ad947fb0a8">&#9670;&nbsp;</a></span>INTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x001c] SC Interrupt Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS
</font><br><p> <font size="2">
Offset: 0x1C  SC Interrupt Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIF</td><td><div style="word-wrap: break-word;"><b>Receive Data Reach Interrupt Status Flag (Read Only)
</b><br>
This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
<br>
Note: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6])
<br>
If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.
<br>
</div></td></tr><tr><td>
[1]</td><td>TBEIF</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Interrupt Status Flag (Read Only)
</b><br>
This field is used for transmit buffer empty interrupt status flag.
<br>
Note: This field is the status flag of transmit buffer empty state
<br>
If software wants to clear this bit, software must write data to DAT(SC_DAT[7:0]) buffer and then this bit will be cleared automatically.
<br>
</div></td></tr><tr><td>
[2]</td><td>TERRIF</td><td><div style="word-wrap: break-word;"><b>Transfer Error Interrupt Status Flag (Read Only)
</b><br>
This field is used for transfer error interrupt status flag
<br>
The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5], parity error PEF(SC_STATUS[4] and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22] and transmitter retry over limit error TXOVERR(SC_STATUS[30]).
<br>
Note: This field is the status flag of BEF(SC_STATUS[6]), FEF(SC_STATUS[5]), PEF(SC_STATUS[4]), RXOV(SC_STATUS[0]), TXOV(SC_STATUS[8]), RXOVERR(SC_STATUS[22]) or TXOVERR(SC_STATUS[30])
<br>
So, if software wants to clear this bit, software must write 1 to each field.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR0IF</td><td><div style="word-wrap: break-word;"><b>Timer0 Interrupt Status Flag (Read Only)
</b><br>
This field is used for TMR0 interrupt status flag.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR1IF</td><td><div style="word-wrap: break-word;"><b>Timer1 Interrupt Status Flag (Read Only)
</b><br>
This field is used for TMR1 interrupt status flag.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR2IF</td><td><div style="word-wrap: break-word;"><b>Timer2 Interrupt Status Flag (Read Only)
</b><br>
This field is used for TMR2 interrupt status flag.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[6]</td><td>BGTIF</td><td><div style="word-wrap: break-word;"><b>Block Guard Time Interrupt Status Flag (Read Only)
</b><br>
This field is used for block guard time interrupt status flag.
<br>
Note1: This bit is valid when RXBGTEN (SC_ALTCTL[12]) is enabled.
<br>
Note2: This bit is read only, but it can be cleared by writing u201C1u201D to it.
<br>
</div></td></tr><tr><td>
[7]</td><td>CDIF</td><td><div style="word-wrap: break-word;"><b>Card Detect Interrupt Status Flag (Read Only)
</b><br>
This field is used for card detect interrupt status flag
<br>
The card detect status is CINSERT (SC_STATUS[12]) and CREMOVE(SC_STATUS[11]).
<br>
Note: This field is the status flag of CINSERT(SC_STATUS[12]) or CREMOVE(SC_STATUS[11])]
<br>
So if software wants to clear these bits, software must write 1 to these field.
<br>
</div></td></tr><tr><td>
[8]</td><td>INITIF</td><td><div style="word-wrap: break-word;"><b>Initial End Interrupt Status Flag (Read Only)
</b><br>
This field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>RXTOIF</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Time-out Interrupt Status Flag (Read Only)
</b><br>
This field is used for receiver buffer time-out interrupt status flag.
<br>
Note: This field is the status flag of receiver buffer time-out state
<br>
If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,
<br>
</div></td></tr><tr><td>
[10]</td><td>ACERRIF</td><td><div style="word-wrap: break-word;"><b>Auto Convention Error Interrupt Status Flag (Read Only)
</b><br>
This field indicates auto convention sequence error
<br>
If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21643">21643</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a7c045cb802cc04954a95356c2308ce4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c045cb802cc04954a95356c2308ce4c">&#9670;&nbsp;</a></span>PINCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::PINCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0024] SC Pin Control State Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PINCTL
</font><br><p> <font size="2">
Offset: 0x24  SC Pin Control State Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PWREN</td><td><div style="word-wrap: break-word;"><b>SC_PWREN Pin Signal
</b><br>
Software can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.
<br>
Write this field to drive SC_PWR pin
<br>
Refer PWRINV (SC_PINCTL[11]) description for programming SC_PWR pin voltage level.
<br>
Read this field to get SC_PWR pin status.
<br>
0 = SC_PWR pin status is low.
<br>
1 = SC_PWR pin status is high.
<br>
Note: When operating at hardware activation, warm reset or deactivation mode, this bit will be changed automatically
<br>
Thus,do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[1]</td><td>SCRST</td><td><div style="word-wrap: break-word;"><b>SC_RST Pin Signal
</b><br>
This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.
<br>
Write this field to drive SC_RST pin.
<br>
0 = Drive SC_RST pin to low.
<br>
1 = Drive SC_RST pin to high.
<br>
Read this field to get SC_RST pin status.
<br>
0 = SC_RST pin status is low.
<br>
1 = SC_RST pin status is high.
<br>
Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically
<br>
Thus,do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[2]</td><td>CREMOVE</td><td><div style="word-wrap: break-word;"><b>Card Detect Removal Status of SC_CD Pin (Read Only)
</b><br>
This bit is set whenever card has been removal.
<br>
0 = No effect.
<br>
1 = Card removed.
<br>
Note1: This bit is read only, but it can be cleared by writing u201C1u201D to it.
<br>
Note2: Card detect engine will start after SCEN (SC_CTL[0])set.
<br>
</div></td></tr><tr><td>
[3]</td><td>CINSERT</td><td><div style="word-wrap: break-word;"><b>Card Detect Insert Status of SC_CD Pin (Read Only)
</b><br>
This bit is set whenever card has been inserted.
<br>
0 = No effect.
<br>
1 = Card insert.
<br>
Note1: This bit is read only, but it can be cleared by writing u201C1u201D to it.
<br>
Note2: The card detect engine will start after SCEN (SC_CTL[0]) set.
<br>
</div></td></tr><tr><td>
[4]</td><td>CDPINSTS</td><td><div style="word-wrap: break-word;"><b>Card Detect Status of SC_CD Pin Status (Read Only)
</b><br>
This bit is the pin status flag of SC_CD
<br>
0 = The SC_CD pin state at low.
<br>
1 = The SC_CD pin state at high.
<br>
</div></td></tr><tr><td>
[6]</td><td>CLKKEEP</td><td><div style="word-wrap: break-word;"><b>SC Clock Enable Bit
</b><br>
0 = SC clock generation Disabled.
<br>
1 = SC clock always keeps free running.
<br>
Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically
<br>
Thus,do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[7]</td><td>ADACEN</td><td><div style="word-wrap: break-word;"><b>Auto Deactivation When Card Removal
</b><br>
0 = Auto deactivation Disabled when hardware detected the card removal.
<br>
1 = Auto deactivation Enabled when hardware detected the card removal.
<br>
Note: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit is set)
<br>
If this process completes, hardware will generate an interrupt INITIF to CPU.
<br>
</div></td></tr><tr><td>
[9]</td><td>SCDOUT</td><td><div style="word-wrap: break-word;"><b>SC Data Output Pin
</b><br>
This bit is the pin status of SCDATOUT but user can drive SCDATOUT pin to high or low by setting this bit.
<br>
0 = Drive SCDATOUT pin to low.
<br>
1 = Drive SCDATOUT pin to high.
<br>
Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically
<br>
Thus,do not fill in this field when SC is in these modes.
<br>
</div></td></tr><tr><td>
[10]</td><td>CDLV</td><td><div style="word-wrap: break-word;"><b>Card Detect Level
</b><br>
0 = When hardware detects the card detect pin (SC_CD) from high to low, it indicates a card is detected.
<br>
1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
<br>
Note: Software must select card detect level before activate Smart Card.
<br>
</div></td></tr><tr><td>
[11]</td><td>PWRINV</td><td><div style="word-wrap: break-word;"><b>SC_POW Pin Inverse
</b><br>
This bit is used for inverse the SC_POW pin.
<br>
There are four kinds of combination for SC_POW pin setting by PWRINV(SC_PINCTL[11]) and PWREN(SC_PINCTL[0])
<br>
PWRINV (SC_PINCTL[11]) is bit 1 and PWREN(SC_PINCTL[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.
<br>
00 = SC_POW_ Pin is 0.
<br>
01 = SC_POW _Pin is 1.
<br>
10 = SC_POW _Pin is 1.
<br>
11 = SC_POW_ Pin is 0.
<br>
Note:Software must select PWRINV (SC_PINCTL[11]) before Smart Card is enabled by SCEN (SC_CTL[0]).
<br>
</div></td></tr><tr><td>
[16]</td><td>DATSTS</td><td><div style="word-wrap: break-word;"><b>SC Data Input Pin Status (Read Only)
</b><br>
This bit is the pin status of SC_DAT
<br>
0 = The SC_DAT pin is low.
<br>
1 = The SC_DAT pin is high.
<br>
</div></td></tr><tr><td>
[30]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator(Read Only)
</b><br>
Due to synchronization, software should check this bit when writing a new value to SC_PINCTL register.
<br>
0 = Synchronizing is completion, user can write new data to SC_PINCTL register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21645">21645</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="ad4c1bc739dc56f6b842cd80a44a70515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c1bc739dc56f6b842cd80a44a70515">&#9670;&nbsp;</a></span>RXTOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::RXTOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0010] SC Receive buffer Time-out Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RXTOUT
</font><br><p> <font size="2">
Offset: 0x10  SC Receive buffer Time-out Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>RFTM</td><td><div style="word-wrap: break-word;"><b>SC Receiver FIFO Time-out
</b><br>
The time-out counter resets and starts counting whenever the RX buffer received a new data word
<br>
Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_DAT buffer, a receiver time-out interrupt INT_RTMR will be generated(if RXTOIF(SC_INTEN[9]) = 1 ).
<br>
Note1:The counter unit is ETU based and the interval of time-out is RFTM + 0.5.
<br>
Note2: Filling in all 0 to this field indicates to disable this function.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21640">21640</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a763cbd039f818865fc97569ebfb553e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763cbd039f818865fc97569ebfb553e3">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0020] SC Transfer Status Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS
</font><br><p> <font size="2">
Offset: 0x20  SC Transfer Status Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXOV</td><td><div style="word-wrap: break-word;"><b>RX Overflow Error Status Flag (Read Only)
</b><br>
This bit is set when RX buffer overflow.
<br>
If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXEMPTY</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Empty Status Flag(Read Only)
</b><br>
This bit indicates RX buffer empty or not.
<br>
When the last byte of Rx buffer has been read by CPU, hardware sets this bit high
<br>
It will be cleared when SC receives any new data.
<br>
</div></td></tr><tr><td>
[2]</td><td>RXFULL</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Full Status Flag (Read Only)
</b><br>
This bit indicates RX buffer full or not.
<br>
This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
<br>
</div></td></tr><tr><td>
[4]</td><td>PEF</td><td><div style="word-wrap: break-word;"><b>Receiver Parity Error Status Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid parity bit.
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
<br>
</div></td></tr><tr><td>
[5]</td><td>FEF</td><td><div style="word-wrap: break-word;"><b>Receiver Frame Error Status Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
<br>
</div></td></tr><tr><td>
[6]</td><td>BEF</td><td><div style="word-wrap: break-word;"><b>Receiver Break Error Status Flag (Read Only)
</b><br>
This bit is set to logic 1 whenever the received data input (RX) held in the spacing state (logic 0) is longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
<br>
</div></td></tr><tr><td>
[8]</td><td>TXOV</td><td><div style="word-wrap: break-word;"><b>TX Overflow Error Interrupt Status Flag (Read Only)
</b><br>
If TX buffer is full, an additional write to DAT(SC_DAT[7:0]) will cause this bit be set to 1 by hardware.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>TXEMPTY</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Status Flag (Read Only)
</b><br>
This bit indicates TX buffer empty or not.
<br>
When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high
<br>
It will be cleared when writing data into DAT(SC_DAT[7:0]) (TX buffer not empty).
<br>
</div></td></tr><tr><td>
[10]</td><td>TXFULL</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Full Status Flag (Read Only)
</b><br>
This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.
<br>
</div></td></tr><tr><td>
[17:16]</td><td>RXPOINT</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Pointer Status Flag (Read Only)
</b><br>
This field indicates the RX buffer pointer status flag
<br>
When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one
<br>
When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.
<br>
</div></td></tr><tr><td>
[21]</td><td>RXRERR</td><td><div style="word-wrap: break-word;"><b>Receiver Retry Error (Read Only)
</b><br>
This bit is set by hardware when RX has any error and retries transfer.
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2 This bit is a flag and cannot generate any interrupt to CPU.
<br>
Note3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
<br>
</div></td></tr><tr><td>
[22]</td><td>RXOVERR</td><td><div style="word-wrap: break-word;"><b>Receiver over Retry Error (Read Only)
</b><br>
This bit is set by hardware when RX transfer error retry over retry number limit.
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
<br>
</div></td></tr><tr><td>
[23]</td><td>RXACT</td><td><div style="word-wrap: break-word;"><b>Receiver in Active Status Flag (Read Only)
</b><br>
This bit is set by hardware when RX transfer is in active.
<br>
This bit is cleared automatically when RX transfer is finished.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>TXPOINT</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Pointer Status Flag (Read Only)
</b><br>
This field indicates the TX buffer pointer status flag
<br>
When CPU writes data into SC_DAT, TXPOINT increases one
<br>
When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.
<br>
</div></td></tr><tr><td>
[29]</td><td>TXRERR</td><td><div style="word-wrap: break-word;"><b>Transmitter Retry Error (Read Only)
</b><br>
This bit is set by hardware when transmitter re-transmits.
<br>
Note1: This bit is read only, but it can be cleared by writing 1 to it.
<br>
Note2 This bit is a flag and cannot generate any interrupt to CPU.
<br>
</div></td></tr><tr><td>
[30]</td><td>TXOVERR</td><td><div style="word-wrap: break-word;"><b>Transmitter over Retry Error (Read Only)
</b><br>
This bit is set by hardware when transmitter re-transmits over retry number limitation.
<br>
Note: This bit is read only, but it can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[31]</td><td>TXACT</td><td><div style="word-wrap: break-word;"><b>Transmit in Active Status Flag (Read Only)
</b><br>
0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed.
<br>
1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21644">21644</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9dd18f1316d1fd3faf6e9f5c2d0d3d">&#9670;&nbsp;</a></span>TMRCTL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0028] SC Internal Timer 0 Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL0
</font><br><p> <font size="2">
Offset: 0x28  SC Internal Timer 0 Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[23:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer 0 Counter Value (ETU Based)
</b><br>
This field indicates the internal timer operation values.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer 0 Operation Mode Selection
</b><br>
This field indicates the internal 24-bit timer operation selection.
<br>
Refer toTable 6.15-3 Timer Operation Mode for programming Timer0.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator(Read Only)
</b><br>
Due to synchronization, software should check this bit when writing a new value to the SC_TMRCTL0 register.
<br>
0 = Synchronizing is completion, user can write new data to SC_TMRCTL0 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21646">21646</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a93ec89f4fa30ee9e8c6480abf814d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ec89f4fa30ee9e8c6480abf814d849">&#9670;&nbsp;</a></span>TMRCTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x002c] SC Internal Timer 1 Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL1
</font><br><p> <font size="2">
Offset: 0x2C  SC Internal Timer 1 Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer 1 Counter Value (ETU Based)
</b><br>
This field indicates the internal timer operation values.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer 1 Operation Mode Selection
</b><br>
This field indicates the internal 8-bit timer operation selection.
<br>
Refer toTable 6.15-3 Timer Operation Mode for programming Timer1.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator(Read Only)
</b><br>
Due to synchronization, software should check this bit when writing a new value to the SC_TMRCTL1 register.
<br>
0 = Synchronizing is completion, user can write new data to SC_TMRCTL1 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21647">21647</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="a12c05c3ae1f45e417764abe3ab1d769c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c05c3ae1f45e417764abe3ab1d769c">&#9670;&nbsp;</a></span>TMRCTL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0030] SC Internal Timer 2 Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL2
</font><br><p> <font size="2">
Offset: 0x30  SC Internal Timer 2 Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer 2 Counter Value (ETU Based)
</b><br>
This field indicates the internal timer operation values.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer 2 Operation Mode Selection
</b><br>
This field indicates the internal 8-bit timer operation selection
<br>
Refer to Table 6.15-3 Timer Operation Mode for programming Timer2.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator(Read Only)
</b><br>
Due to synchronization, software should check this bit when writing a new value to SC_TMRCTL2 register.
<br>
0 = Synchronizing is completion, user can write new data to SC_TMRCTL2 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21648">21648</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<a id="aaea818bd8186138fa212ebf17ffbd8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea818bd8186138fa212ebf17ffbd8d5">&#9670;&nbsp;</a></span>UARTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::UARTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[0x0034] SC UART Mode Control Register.</p>
<p> 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">UARTCTL
</font><br><p> <font size="2">
Offset: 0x34  SC UART Mode Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>UARTEN</td><td><div style="word-wrap: break-word;"><b>UART Mode Enable Bit
</b><br>
0 = Smart Card mode.
<br>
1 = UART mode.
<br>
Note1: When operating in UART mode, user must set CONSEL (SC_CTL[5:4]) = 00 and AUTOCEN(SC_CTL[3]) = 0.
<br>
Note2: When operating in Smart Card mode, user must set UARTEN(SC_UARTCTL [0]) = 00.
<br>
Note3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>WLS</td><td><div style="word-wrap: break-word;"><b>Word Length Selection
</b><br>
00 = Word length is 8 bits.
<br>
01 = Word length is 7 bits.
<br>
10 = Word length is 6 bits.
<br>
11 = Word length is 5 bits.
<br>
Note: In smart card mode, this WLS must be '00'
<br>
</div></td></tr><tr><td>
[6]</td><td>PBOFF</td><td><div style="word-wrap: break-word;"><b>Parity Bit Disable Control
</b><br>
0 = Parity bit is generated or checked between the last data word bit and stop bit of the serial data.
<br>
1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
<br>
Note: In smart card mode, this field must be '0' (default setting is with parity bit)
<br>
</div></td></tr><tr><td>
[7]</td><td>OPE</td><td><div style="word-wrap: break-word;"><b>Odd Parity Enable Bit
</b><br>
0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
<br>
1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
<br>
Note: This bit has effect only when PBOFF bit is '0'.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="_nano103_8h_source.html#l21649">21649</a> of file <a class="el" href="_nano103_8h_source.html">Nano103.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano103bsp/Library/Device/Nuvoton/Nano103/Include/<a class="el" href="_nano103_8h_source.html">Nano103.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 19:35:34 for Nano103 BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
